/* -*- mode: C -*-
   translate.def
   
   Actual transformation of each bytecodes
   This file will be included into cfg_generator.c
   
   Written by: SeungIl Lee <hacker@altair.snu.ac.kr>
   
   Copyright (C) 1999 MASS Lab., Seoul, Korea.
   
   See the file LICENSE for usage and redistribution terms and a
   disclaimer of all warranties. */

extern int next_pc;
extern InstrNode *last_instr;

/* for a given bytecode instruction its function name becomes
   translate_bytecode */
#define translate_instr(bytecode)				\
    void translate_##bytecode##(CFG *cfg, 			\
                                Method *method, 	        \
                                InstrOffset pc,			\
                                InstrNode *p_instr)

/* for a given npc, set next_pc to npc, and set last_instr */
#define PROCESS_AND_VERIFY_FOR_NPC(npc)				\
{							        \
    next_pc = npc;                                              \
    CFGGen_process_and_verify_for_npc(next_pc, c_instr);       	\
    last_instr = c_instr;                                       \
}

#ifdef BYTECODE_PROFILE
#define INSERT_DEBUG_CODE() \
    c_instr = CSeq_insert_debug_code(cfg, c_instr, method, pc); \
    APPEND_NOP()
#else /* not BYTECODE_PROFILE */
#define INSERT_DEBUG_CODE() 
#endif /* not BYTECODE_PROFILE */

translate_instr(NOP)
{
    //
    // do nothing
    //
    InstrNode *c_instr = p_instr;

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(ACONST_NULL)
{
    //
    // ... -> ..., 0
    //
    // add  g0, 0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, RS(ops_top + 1), g0, 0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_M1)
{
    //
    // ... -> ..., -1
    //
    // add  g0, -1, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, -1);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_0)
{
    //
    // ... -> ..., 0
    //
    // add  g0, 0, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_1)
{
    //
    // ... -> ..., 1
    //
    // add  g0, 1, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 1);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_2)
{
    //
    // ... -> ..., 2
    //
    // add  g0, 2, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 2);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_3)
{
    //
    // ... -> ..., 3
    //
    // add  g0, 3, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 3);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_4)
{
    //
    // ... -> ..., 4
    //
    // add  g0, 4, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 4);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ICONST_5)
{
    //
    // ... -> ..., 5
    //
    // add  g0, 5, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, 5);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LCONST_0)
{
    //
    // ... -> ..., 0, 0
    //
    // add  g0, 0, ls{TOP+1}
    // add  g0, 0, ivs{TOP+2} 
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, LS(ops_top + 1), g0, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IVS(ops_top + 2), g0, 0);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LCONST_1)
{
    //
    // ... -> ..., 0, 1
    //
    // add  g0, 0, ls{TOP+1}
    // add  g0, 1, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR5(ADD, LS(ops_top + 1), g0, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IVS(ops_top + 2), g0, 1);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

/* Actually, SPARC doest not support immediate move to a float
   register.  Therefore, somewhat tedious sequence of instructions
   should be generated.  The heap area of JVM contains 0.0F, 1.0F,
   2.0F, 0.0LF, 1.0LF, and 2.0LF, whose variable name is
   'offst_of_0_0F', 'offset_of_1_0F', 'offset_of_2_0F',
   'offset_of_0_0LF', 'offset_of_1_0LF', and 'offset_of_2_0LF' each. */

translate_instr(FCONST_0)
{
    //
    // ... -> ..., 0.0
    //
    // sethi  %hi(offset_of_0_0F), it0
    // ldf    [it0 + %lo(offset_of_0_0F)], fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR2(SETHI, IT(0), HI(offset_of_0_0F));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(LDF, FS(ops_top + 1), IT(0), LO(offset_of_0_0F));
    Instr_SetLastUseOfSrc(c_instr, 0);
    
    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FCONST_1)
{
    //
    // ... -> ..., 1.0
    //
    // 
    // sethi  %hi(offset_of_1_0F), it0
    // ldf    [it0 + %lo(offset_of_1_0F)], fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    
    APPEND_INSTR2(SETHI, IT(0), HI(offset_of_1_0F));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(LDF, FS(ops_top + 1), IT(0), LO(offset_of_1_0F));
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FCONST_2)
{
    //
    // ... -> ..., 2.0
    //
    // sethi  %hi(offset_of_2_0F), it0
    // ldf    [it0 + %lo(offset_of_2_0F)], fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR2(SETHI, IT(0), HI(offset_of_2_0F));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(LDF, FS(ops_top + 1), IT(0), LO(offset_of_2_0F));
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DCONST_0)
{
    //
    // ... -> ..., 0.0LF
    //
    // sethi  %hi(offset_of_0_0LF), it0
    // lddf   [it0 + %lo(offset_of_0_0LF)], ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR2(SETHI, IT(0), HI(offset_of_0_0LF));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(LDDF, DS(ops_top + 1), IT(0), LO(offset_of_0_0LF));
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DCONST_1)
{
    //
    // ... -> ..., 1.0LF
    //
    // sethi  %hi(offset_of_1_0LF), it0
    // lddf   [it0 + %lo(offset_of_1_0LF)], ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR2(SETHI, IT(0), HI(offset_of_1_0LF));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(LDDF, DS(ops_top + 1), IT(0), LO(offset_of_1_0LF));
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(BIPUSH)
{
    //
    // ... -> ..., val
    //
    // add  g0, val, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    uint8 *bcode;
    int32 val;

    bcode = Method_GetByteCode(method);
    val =  (int32) BCode_get_int8(bcode + pc + 1);

    APPEND_INSTR5(ADD, IS(ops_top + 1), g0, val);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 2);
}

translate_instr(SIPUSH)
{
    //
    // ... -> ..., val
    //
    // sethi  %hi(val), it0
    // or     it0, %(val), is{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    uint8 *bcode;
    int32 val;

    bcode = Method_GetByteCode(method);
    val = (int32) BCode_get_int16(bcode + pc + 1);

    if ((val <= MAX_SIMM13) && (val >= MIN_SIMM13)) {
        APPEND_INSTR5(ADD, IS(ops_top+1), g0, val);
        translated_instrs[pc] = c_instr;
    } else {        
        APPEND_INSTR2(SETHI, IT(0), HI(val));
        translated_instrs[pc] = c_instr;
        APPEND_INSTR5(OR, IS(ops_top + 1), IT(0), LO(val));
        Instr_SetLastUseOfSrc(c_instr, 0); 
    }

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}


translate_instr(LDC1)
{
    //
    // ... -> ..., const
    //
    InstrNode *c_instr = p_instr;
    Hjava_lang_Class *class;
    uint32 pool_index;
    byte const_type;
    word const_data;
    int offset;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    pool_index = (uint32) BCode_get_uint8(bcode + pc + 1);

    class = Method_GetDefiningClass(method);
    const_type = Class_GetCPEntryType(class, pool_index);
    const_data = Class_GetCPEntryData(class, pool_index);
    
    switch (const_type) {
      case CONSTANT_ResolvedString:
        //
        // sethi  %hi(const_data), it0
        // or     %it0, %lo(const_data), rs{TOP+1}
        //
	APPEND_INSTR2(SETHI, IT(0), HI(const_data));
        translated_instrs[pc] = c_instr;
	APPEND_INSTR5(OR, RS(ops_top + 1), IT(0), LO(const_data));
	Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_REF);

        break;
      case CONSTANT_Float:
        //
        // A new data entry is created for the const_value.
        //
        // sethi  %hi(DATA+const_data_offset), it0
        // ldf    [%it0 + %lo(DATA+const_data_offset), fs{TOP+1}
        //
        offset = CFG_AddNewDataEntry(cfg, NORMAL, sizeof(float), 
				     (void *) const_data, ALIGN_WORD);

	APPEND_INSTR2(SETHI, IT(0), 0);
        translated_instrs[pc] = c_instr;
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
	APPEND_INSTR5(LDF, FS(ops_top + 1), IT(0), 0);
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_FLOAT);

        break;
      case CONSTANT_Integer:
        //
        // sethi  %hi(const_value), it0
        // or     it0, %lo(const_value), is{TOP+1}
        //
	APPEND_INSTR2(SETHI, IT(0), HI(const_data));
	translated_instrs[pc] = c_instr;
	APPEND_INSTR5(OR, IS(ops_top + 1), IT(0), LO(const_data));
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_INT);

        break;
      default:
        assert(false);
    }

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 2);
}


translate_instr(LDC2)
{
    //
    // ... -> ..., const
    //
    InstrNode *c_instr = p_instr;
    Hjava_lang_Class *class;
    uint32 pool_index;
    byte const_type;
    word const_data;
    int offset;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    pool_index = (uint32) BCode_get_uint16(bcode + pc + 1);

    class = Method_GetDefiningClass(method);
    const_type = Class_GetCPEntryType(class, pool_index);
    const_data = Class_GetCPEntryData(class, pool_index);
    
    switch (const_type) {
      case CONSTANT_ResolvedString:
        //
        // sethi  %hi(const_data), it0
        // or     %it0, %lo(const_data), rs{TOP+1}
        //
        APPEND_INSTR2(SETHI, IT(0), HI(const_data));
        translated_instrs[pc] = c_instr;
	APPEND_INSTR5(OR, RS(ops_top + 1), IT(0), LO(const_data));
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_REF);

        break;
      case CONSTANT_Float:
        //
        // A new data entry is created for the const_value.
        //
        // sethi  %hi(DATA+const_data_offset), it0
        // ldf    [%it0 + %lo(DATA+const_data_offset), fs{TOP+1}
        //
        offset = CFG_AddNewDataEntry(cfg, NORMAL, sizeof(float), 
				     (void *) const_data, ALIGN_WORD);

	APPEND_INSTR2(SETHI, IT(0), 0);
	translated_instrs[pc] = c_instr;
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
	APPEND_INSTR5(LDF, FS(ops_top + 1), IT(0), 0);
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_FLOAT);

        break;
      case CONSTANT_Integer:
        //
        // sethi  %hi(const_value), it0
        // or     it0, %lo(const_value), is{TOP+1}
        //
	APPEND_INSTR2(SETHI, IT(0), HI(const_data));
	translated_instrs[pc] = c_instr;
	APPEND_INSTR5(OR, IS(ops_top + 1), IT(0), LO(const_data));
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_INT);

        break;
      default:
        assert(false);
    }

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(LDC2W)
{
    //
    // ... -> ..., long const
    //
    InstrNode *c_instr = p_instr;
    Hjava_lang_Class *class;
    uint32 pool_index;
    byte const_type;
    int *data;
    int offset;
    uint8 *bcode;
    
    bcode = Method_GetByteCode(method);
    pool_index = (uint32) BCode_get_uint16(bcode + pc + 1);

    class = Method_GetDefiningClass(method);
    const_type = Class_GetCPEntryType(class, pool_index);

    data = (int *) FMA_calloc(sizeof(int) * 2);
    
    data[0] = Class_GetCPEntryData(class, pool_index);
    data[1] = Class_GetCPEntryData(class, pool_index + 1);

    switch (const_type) {
      case CONSTANT_Long:
        //
        // sethi  %hi(DATA+data_offset), it0
        // ld     [it0 + %lo(DATA+data_offset)], ls{TOP+1}
        // ld     [it0 + %lo(DATA+data_offset+4)], ivs{TOP+2}
        //
	offset = CFG_AddNewDataEntry(cfg, NORMAL, sizeof(double),
				     (void *) data, ALIGN_DOUBLE_WORD);

	APPEND_INSTR2(SETHI, IT(0), 0);
        translated_instrs[pc] = c_instr;
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
	APPEND_INSTR5(LD, LS(ops_top + 1), IT(0), 0);
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
	APPEND_INSTR5(LD, IVS(ops_top + 2), IT(0), 0);
        add_new_resolve_instr(cfg, c_instr, (void *) offset + 4);
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_LONG);
	set_ops_type(ops_top + 2, T_IVOID);

        break;
      case CONSTANT_Double:
        //
        // sethi  %hi(DATA+data_offset), it0
        // lddf   [it0 + %lo(DATA+data_offset)], ds{TOP+1}
        //
        offset = CFG_AddNewDataEntry(cfg, NORMAL, sizeof(double),
				     (void *) data, ALIGN_DOUBLE_WORD);
	
	APPEND_INSTR2(SETHI, IT(0), 0);
        translated_instrs[pc] = c_instr;
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
	APPEND_INSTR5(LDDF, DS(ops_top + 1), IT(0), 0);
        add_new_resolve_instr(cfg, c_instr, (void *) offset);
        Instr_SetLastUseOfSrc(c_instr, 0);

	set_ops_type(ops_top + 1, T_DOUBLE);
	set_ops_type(ops_top + 2, T_FVOID);

        break;
      default:
        assert(false);
    }

    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(ILOAD)
{
    //
    // ... -> ..., local variable
    //
    // add  il{index}, g0, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, IS(ops_top + 1), IL(index), g0);
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, IS(ops_top + 1), IL(index), g0);
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(LLOAD)
{
    //
    // ... -> ..., long local variable
    //
    // add  ll{index}, g0, ls{TOP+1}
    // add  ivl{index}, g0, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, LS(ops_top + 1), LL(index), g0);
        translated_instrs[pc - 1] = c_instr;
	APPEND_INSTR6(ADD, IVS(ops_top + 2), IVL(index + 1), g0);

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, LS(ops_top + 1), LL(index), g0);
        translated_instrs[pc] = c_instr;
	APPEND_INSTR6(ADD, IVS(ops_top + 2), IVL(index + 1), g0);

        npc = pc + 2;
    }

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(FLOAD)
{
    //
    // ... -> ..., local variable
    //
    // fmovs  fl{index}, fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);
	
	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(index));
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(index));
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(DLOAD)
{
    //
    // ... -> ..., double local variable
    //
    // fmovd  dl{index}, ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);

    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(index));
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(index));
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(ALOAD)
{
    //
    // ... -> ..., local variable
    //
    // add  rl{index}, g0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);

    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, RS(ops_top + 1), RL(index), g0);
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, RS(ops_top + 1), RL(index), g0);
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(ILOAD_0)
{
    //
    // ... -> ..., local variable
    //
    // add  il0, g0, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, IS(ops_top + 1), IL(0), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ILOAD_1)
{
    //
    // ... -> ..., local variable
    //
    // add  il1, g0, is{TOP+1}
    //
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, IS(ops_top + 1), IL(1), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ILOAD_2)
{
    //
    // ... -> ..., local variable
    //
    // add  il2, g0, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, IS(ops_top + 1), IL(2), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ILOAD_3)
{
    //
    // ... -> ..., local variable
    //
    // add  il3, g0, is{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, IS(ops_top + 1), IL(3), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_INT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LLOAD_0)
{
    //
    // ... -> ..., long local variable
    //
    // add  ll0, g0, ls{TOP+1}
    // add  ivl1, g0, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;


    APPEND_INSTR6(ADD, LS(ops_top + 1), LL(0), g0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(ADD, IVS(ops_top + 2), IVL(1), g0);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LLOAD_1)
{
    //
    // ... -> ..., long local variable
    //
    // add  ll1, g0, ls{TOP+1}
    // add  ivl2, g0, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, LS(ops_top + 1), LL(1), g0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(ADD, IVS(ops_top + 2),IVL(2), g0);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LLOAD_2)
{
    //
    // ... -> ..., long local variable
    //
    // add  ll2, g0, ls{TOP+1}
    // add  ivl3, g0, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, LS(ops_top + 1), LL(2), g0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(ADD, IVS(ops_top + 2), IVL(3), g0);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}
translate_instr(LLOAD_3)
{
    //
    // ... -> ..., long local variable
    //
    // add  ll3, g0, ls{TOP+1}
    // add  ivl4, g0, ivs{TOP+2}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, LS(ops_top + 1), LL(3), g0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(ADD, IVS(ops_top + 2), IVL(4), g0);

    set_ops_type(ops_top + 1, T_LONG);
    set_ops_type(ops_top + 2, T_IVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FLOAD_0)
{
    //
    // ... -> ..., local variable
    //
    // fmovs  fl0, fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(0));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FLOAD_1)
{
    //
    // ... -> ..., local variable
    //
    // fmovs  fl1, fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(1));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FLOAD_2)
{
    //
    // ... -> ..., local variable
    //
    // fmovs  fl2, fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(2));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}
translate_instr(FLOAD_3)
{
    //
    // ... -> ..., local variable
    //
    // fmovs  fl0, fs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FL(3));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_FLOAT);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DLOAD_0)
{
    //
    // ... -> ..., double local variable
    //
    // fmovd  dl0, ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;


    APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(0));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DLOAD_1)
{
    //
    // ... -> ..., double local variable
    //
    // fmovd  dl1, ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(1));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}
translate_instr(DLOAD_2)
{
    //
    // ... -> ..., double local variable
    //
    // fmovd  dl2, ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(2));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}
translate_instr(DLOAD_3)
{
    //
    // ... -> ..., double local variable
    //
    // fmovd  dl3, ds{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    c_instr = APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DL(3));
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_DOUBLE);
    set_ops_type(ops_top + 2, T_FVOID);
    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ALOAD_0)
{
    //
    // ... -> ..., local variable
    //
    // add  rl0, g0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;


    APPEND_INSTR6(ADD, RS(ops_top + 1), RL(0), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ALOAD_1)
{
    //
    // ... -> ..., local variable
    //
    // add  rl1, g0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, RS(ops_top + 1), RL(1), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ALOAD_2)
{
    //
    // ... -> ..., local variable
    //
    // add  rl2, g0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;

    APPEND_INSTR6(ADD, RS(ops_top + 1), RL(2), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ALOAD_3)
{
    //
    // ... -> ..., local variable
    //
    // add  rl3, g0, rs{TOP+1}
    //
    InstrNode *c_instr = p_instr;


    APPEND_INSTR6(ADD, RS(ops_top + 1), RL(3), g0);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IALOAD)
{
    //
    // ..., array ref, index -> ..., value
    //
    //      shl  is{TOP}, 2, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      ld   [rs{TOP-1} + it1], is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc, 
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LD, IS(ops_top - 1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_INT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LALOAD)
{
    //
    // ..., array ref, index -> ..., long value
    //
    //      add  rs{TOP-1}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP}, 3, it1
    //      add  it0, it1, rt2
    //      ld   [rt2], ls{TOP-1}
    //      ld   [rt2+4], ivs{TOP}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(ADD, IT(0), RS(ops_top - 1), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLL, IT(1), IS(ops_top), 3);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, RT(2), IT(0), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LD, LS(ops_top - 1), RT(2), 0);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    APPEND_INSTR5(LD, IVS(ops_top), RT(2), 4);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 1, T_LONG);
    set_ops_type(ops_top, T_IVOID);
    /* no change to operand stack top value */

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FALOAD)
{
    //
    // ..., array ref, index -> ..., float value
    //
    //      shl  is{TOP}, 2, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      ldf  [rs{TOP-1} + it1], fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LDF, FS(ops_top -1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_FLOAT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(DALOAD)
{
    //
    // ..., array ref, index -> ..., double value
    //
    //      shl  is{TOP}, 3, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      lddf [rs{TOP-1} + it1], ds{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 3);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LDDF, DS(ops_top - 1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_DOUBLE);
    set_ops_type(ops_top, T_FVOID);
    /* no change to ops_top value */

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(AALOAD)
{
    //
    // ..., array ref, index -> ..., ref value
    //
    //      shl  is{TOP}, 2, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      ld   [rs{TOP-1} + it1], rs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LD, RS(ops_top - 1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_REF);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(BALOAD)
{
    //
    // ..., array ref, index -> ..., byte value
    //
    //      add  is{TOP}, ARRAY_DATA_OFFSET, it0
    //      ldsb [rs{TOP-1} + it0], is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(ADD, IT(0), IS(ops_top), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LDSB, IS(ops_top-1), RS(ops_top - 1), IT(0));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_INT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(CALOAD)
{
    //
    // ..., array ref, index -> ..., char value
    //
    //      shl  is{TOP}, 1, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      lduh [rs{TOP-1} + it1], is{TOP-1}
    //  'char' is treated as unsigned short.
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 1);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LDUH, IS(ops_top - 1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_INT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(SALOAD)
{
    //
    // ..., array ref, index -> ..., char value
    //
    //      shl  is{TOP}, 1, it0
    //      add  it0, ARRAY_DATA_OFFSET, it1
    //      ldsh [rs{TOP-1} + it1], is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 1, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 1);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LDSH, IS(ops_top - 1), RS(ops_top - 1), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - 1, T_INT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(ISTORE)
{
    //
    // ..., value -> ...
    //
    // add  is{TOP}, g0, il{index}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, IL(index), IS(ops_top), g0);
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, IL(index), IS(ops_top), g0);
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(index);
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}


translate_instr(LSTORE)
{
    //
    // ..., long value -> ...
    //
    // add  ls{TOP-1}, g0, ll{index}
    // add  ivs{TOP}, g0, ivl{index + 1}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, LL(index), LS(ops_top - 1), g0);
        translated_instrs[pc - 1] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR6(ADD, IVL(index + 1), IVS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, LL(index), LS(ops_top-1), g0);
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
	APPEND_INSTR6(ADD, IVL(index + 1), IVS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        npc = pc + 2;
    }

    ops_top -= 2;

    set_local_variable_type(index);
    set_local_variable_type(index + 1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(FSTORE)
{
    //
    // ..., float value -> ...
    //
    // fmovs  fs{TOP}, fl{index}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_FLOAT);

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(FMOVS, FL(index), g0, FS(ops_top));
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(FMOVS, FL(index), g0, FS(ops_top));
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    set_local_variable_type(index);
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(DSTORE)
{
    //
    // ..., double value -> ...
    //
    // fmovd  ds{TOP-1}, dl{index}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    bcode = Method_GetByteCode(method);

    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(FMOVD, DL(index), g0, DS(ops_top - 1));
        translated_instrs[pc - 1] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(FMOVD, DL(index), g0, DS(ops_top - 1));
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);

        npc = pc + 2;
    }

    ops_top -= 2;

    set_local_variable_type(index);
    set_local_variable_type(index + 1);
    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(ASTORE)
{
    //
    // ..., ref value -> ...
    //
    // add  rs{TOP}, g0, rl{index}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_REF);

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);

	APPEND_INSTR6(ADD, RL(index), RS(ops_top), g0);
        translated_instrs[pc - 1] = c_instr;

        wide = false;
        npc = pc + 3;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);

	APPEND_INSTR6(ADD, RL(index), RS(ops_top), g0);
        translated_instrs[pc] = c_instr;

        npc = pc + 2;
    }
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(index);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(ISTORE_0)
{
    //
    // ..., value -> ...
    //
    // add  is{TOP}, g0, il0
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(ADD, IL(0), IS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ISTORE_1)
{
    //
    // ..., value -> ...
    //
    // add  is{TOP}, g0, il1
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(ADD, IL(1), IS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ISTORE_2)
{
    //
    // ..., value -> ...
    //
    // add  is{TOP}, g0, il2
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(ADD, IL(2), IS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ISTORE_3)
{
    //
    // ..., value -> ...
    //
    // add  is{TOP}, g0, il3
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(ADD, IL(3), IS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(3);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSTORE_0)
{
    //
    // ..., long value -> ...
    //
    // add  ls{TOP-1}, g0, ll0
    // add  ivs{TOP}, g0, ivl1
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(ADD, LL(0), LS(ops_top-1), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IVL(1), IVS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top -= 2;

    set_local_variable_type(0);
    set_local_variable_type(1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(LSTORE_1)
{
    //
    // ..., long value -> ...
    //
    // add  ls{TOP-1}, g0, ll1
    // add  ivs{TOP}, g0, ivl2
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(ADD, LL(1), LS(ops_top-1), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IVL(2), IVS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top -= 2;

    set_local_variable_type(1);
    set_local_variable_type(2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSTORE_2)
{
    //
    // ..., long value -> ...
    //
    // add  ls{TOP-1}, g0, ll2
    // add  ivs{TOP}, g0, ivl3
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(ADD, LL(2), LS(ops_top-1), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IVL(3), IVS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top -= 2;

    set_local_variable_type(2);
    set_local_variable_type(3);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSTORE_3)
{
    //
    // ..., long value -> ...
    //
    // add  ls{TOP-1}, g0, ll3
    // add  ivs{TOP}, g0, ivl4
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(ADD, LL(3), LS(ops_top-1), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IVL(4), IVS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top -= 2;

    set_local_variable_type(3);
    set_local_variable_type(4);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FSTORE_0)
{
    //
    // ..., float value -> ...
    //
    // fmovs  fs{TOP}, fl0
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FMOVS, FL(0), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    set_local_variable_type(0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FSTORE_1)
{
    //
    // ..., float value -> ...
    //
    // fmovs  fs{TOP}, fl1
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FMOVS, FL(1), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    set_local_variable_type(1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FSTORE_2)
{
    //
    // ..., float value -> ...
    //
    // fmovs  fs{TOP}, fl2
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FMOVS, FL(2), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    set_local_variable_type(2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FSTORE_3)
{
    //
    // ..., float value -> ...
    //
    // fmovs  fs{TOP}, fl3
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FMOVS, FL(3), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    set_local_variable_type(3);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DSTORE_0)
{
    //
    // ..., double value -> ...
    //
    // fmovd  ds{TOP-1}, dl0
    //

    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FMOVD, DL(0), g0, DS(ops_top-1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    set_local_variable_type(0);
    set_local_variable_type(1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DSTORE_1)
{
    //
    // ..., double value -> ...
    //
    // fmovd  ds{TOP-1}, dl1
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FMOVD, DL(1), g0, DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    set_local_variable_type(1);
    set_local_variable_type(2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DSTORE_2)
{
    //
    // ..., double value -> ...
    //
    // fmovd  ds{TOP-1}, dl2
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FMOVD, DL(2), g0, DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    set_local_variable_type(2);
    set_local_variable_type(3);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DSTORE_3)
{
    //
    // ..., double value -> ...
    //
    // fmovd  ds{TOP-1}, dl3
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top-1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FMOVD, DL(3), g0, DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    set_local_variable_type(3);
    set_local_variable_type(4);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ASTORE_0)
{
    //
    // ..., ref value -> ...
    //
    // add  rs{TOP}, g0, rl0
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    APPEND_INSTR6(ADD, RL(0), RS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ASTORE_1)
{
    //
    // ..., ref value -> ...
    //
    // add  rs{TOP}, g0, rl1
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    APPEND_INSTR6(ADD, RL(1), RS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ASTORE_2)
{
    //
    // ..., ref value -> ...
    //
    // add  rs{TOP}, g0, rl2
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    APPEND_INSTR6(ADD, RL(2), RS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ASTORE_3)
{
    //
    // ..., ref value -> ...
    //
    // add  rs{TOP}, g0, rl3
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    APPEND_INSTR6(ADD, RL(3), RS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    ops_top--;

    set_local_variable_type(3);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IASTORE)
{
    //
    // ..., array ref, index, val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP-1}, 2, it1
    //      st   is{TOP}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 1), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(ST, IS(ops_top), RS(ops_top - 2), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LASTORE)
{
    //
    // ..., array ref, index, long val -> ...
    //
    //      add  rs{TOP-3}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP-2}, 3, it1
    //      add  it0, it1, it2
    //      st   ls{TOP-1}, [it2]
    //      st   ivs{TOP}, [it2+4]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_REF);
    assert(get_ops_type(ops_top - 2) == T_INT);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 3, ops_top - 2);

    APPEND_INSTR5(ADD, IT(0), RS(ops_top - 3), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLL, IT(1), IS(ops_top - 2), 3);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IT(2), IT(0), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(ST, LS(ops_top - 1), IT(2), 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    APPEND_INSTR8(ST, IVS(ops_top), IT(2), 4);
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 4;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FASTORE)
{
    //
    // ..., array ref, index, float val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP-1}, 2, it1
    //      stf  fs{TOP}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_FLOAT);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 1), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(STF, FS(ops_top), RS(ops_top - 2), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DASTORE)
{
    //
    // ..., array ref, index, double val -> ...
    //
    //      add  rs{TOP-3}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP-2}, 3, it1
    //      stdf ds{TOP-1}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_REF);
    assert(get_ops_type(ops_top - 2) == T_INT);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 3, ops_top - 2);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 2), 3);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(STDF, DS(ops_top - 1), RS(ops_top - 3), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 4;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(AASTORE)
{
    //
    // ..., array ref, index, ref val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      shl  is{TOP-1}, 2, it1
    //      st   rs{TOP}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_REF);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);
    /* AASTORE needs additional type check */
    c_instr = CSeq_create_array_store_checking_code(cfg, c_instr, pc, NULL,
						    ops_top - 2, ops_top);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 1), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(ST, RS(ops_top), RS(ops_top - 2), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(BASTORE)
{
    //
    // ..., array ref, index, byte val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      stb  is{TOP}, [it0 + is{TOP-1}]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);

    APPEND_INSTR5(ADD, IT(0), IS(ops_top - 1), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(STB, IS(ops_top), RS(ops_top - 2), IT(0));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(CASTORE)
{
    //
    // ..., array ref, index, char val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      sll  is{TOP-1}, 1, it1
    //      sth  is{TOP}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 1), 1);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    APPEND_INSTR7(STH, IS(ops_top), RS(ops_top - 2), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(SASTORE)
{
    //
    // ..., array ref, index, short val -> ...
    //
    //      add  rs{TOP-2}, ARRAY_DATA_OFFSET, it0
    //      sll  is{TOP-1}, 1, it1
    //      sth  is{TOP}, [it0 + it1]
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_REF);
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    /* make the array bounds check code sequence */
    c_instr = CSeq_create_array_bound_checking_code(cfg, c_instr, pc,
						    &translated_instrs[pc],
						    ops_top - 2, ops_top - 1);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top - 1), 1);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, IT(1), IT(0), ARRAY_DATA_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR7(STH, IS(ops_top), RS(ops_top - 2), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    Instr_SetLastUseOfSrc(c_instr, 2);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(POP)
{
    //
    // ..., val -> ...
    //
    InstrNode *c_instr = p_instr;
    int data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add	g0, is{TOP}, g0
	//
	APPEND_INSTR6(ADD, g0, IS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add	g0, rs{TOP}, g0
	//
	APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, g0
	//
	APPEND_INSTR6(FMOVS, g0, g0, FS(ops_top));
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(POP2)
{
    //
    // ..., val, val -> ...
    //
    InstrNode *c_instr = p_instr;
    int data_type;

    /* pop first element */
    data_type= get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, IS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, g0
	//
	APPEND_INSTR6(FMOVS, g0, g0, FS(ops_top));
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_IVOID:
	//
	// add  ivs{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, IVS(ops_top), g0);
	translated_instrs[pc] = c_instr;
	Instr_SetLastUseOfSrc(c_instr, 0);
	break;

      case T_FVOID: 
	break;

      default:
        assert(false);
    }

    ops_top--;

    /* pop second element */
    data_type= get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, g0
	//
	APPEND_INSTR6(FMOVS, g0, g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_LONG:
	//
	// add  ls{TOP}, g0, g0
	//
	APPEND_INSTR6(ADD, g0, LS(ops_top), g0);
	Instr_SetLastUseOfSrc(c_instr, 0);
	break;

      case T_DOUBLE:
	//
	// fmovd  ds{TOP}, g0
	//
	APPEND_INSTR6(FMOVD, g0, g0, DS(ops_top));
	Instr_SetLastUseOfSrc(c_instr, 1);
	translated_instrs[pc] = c_instr;
	break;

      default:
        assert(false);
    }

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP)
{
    //
    // ..., val -> ..., val, val
    //
    InstrNode *c_instr = p_instr;
    int data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP}, g0, is{TOP+1}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        break;

      case T_REF:
	// 
	// add  rs{TOP}, g0, rs{TOP+1}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top), g0);
        translated_instrs[pc] = c_instr;
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP}, fs{TOP+1}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top));
        translated_instrs[pc] = c_instr;
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top + 1, data_type);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP_X1)
{
    //
    // ..., val2, val1 -> ..., val1, val2, val1
    //
    // val1 and val2 can only be 32-bit data types.
    //
    InstrNode *c_instr = p_instr;
    int data_type;


    /* move val1 */
    data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP}, g0, is{TOP+1}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP}, g0, rs{TOP+1}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, fs{TOP+1}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;
    set_ops_type(ops_top + 1, data_type);

    /* move val2 */
    data_type = get_ops_type(ops_top - 1);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-1}, g0, is{TOP}
	//
        APPEND_INSTR6(ADD, IS(ops_top), IS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-1}, g0, rs{TOP}
	//
        APPEND_INSTR6(ADD, RS(ops_top), RS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-1}, fs{TOP}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top), g0, FS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top, data_type);

    /* duplicate val1 */
    data_type = get_ops_type(ops_top + 1);

    switch (data_type) {
      case T_INT:
        APPEND_INSTR6(ADD, IS(ops_top - 1), IS(ops_top + 1), g0);
        break;

      case T_REF:
        APPEND_INSTR6(ADD, RS(ops_top - 1), RS(ops_top + 1), g0);
        break;

      case T_FLOAT:
        APPEND_INSTR6(FMOVS, FS(ops_top - 1), g0, FS(ops_top + 1));
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 1, data_type);

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP_X2)
{
    //
    // ..., val3, val2, val1 -> ..., val1, val3, val2, val1
    //
    // val2 and val3 should contain 32-bit data types or be the two
    // words of a single 64-bit datum. val1 should contain 32-bit data
    // type.
    //
    InstrNode *c_instr = p_instr;
    int data_type;

    /* move val1 */
    data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP}, g0, is{TOP+1}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	// 
	// add  rs{TOP}, g0, rs{TOP+1}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP}, fs{TOP+1}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;
    set_ops_type(ops_top + 1, data_type);

    /* move val2 */
    data_type = get_ops_type(ops_top - 1);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP-1}, g0, is{TOP}
	//
	APPEND_INSTR6(ADD, IS(ops_top), IS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	// 
	// add  rs{TOP-1}, g0, rs{TOP}
	//
        APPEND_INSTR6(ADD, RS(ops_top), RS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP-1}, fs{TOP}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top), g0, FS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_IVOID:
	// 
	// add  ivs{TOP-1}, g0, ivs{TOP}
	//
        APPEND_INSTR6(ADD, IVS(ops_top), IVS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
	break;

      case T_FVOID:		// 64 bit data
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top, data_type);

    /* move val3 */
    data_type = get_ops_type(ops_top - 2);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP-2}, g0, is{TOP-1}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 1), IS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	// 
	// add  rs{TOP-2}, g0, rs{TOP-1}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 1), RS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP-2}, fs{TOP-1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 1), g0, FS(ops_top - 2));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_LONG:
	// 
	// add  ls{TOP-2}, g0, ls{TOP-1}
	//
        APPEND_INSTR6(ADD, LS(ops_top - 1), LS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_DOUBLE:
	// 
	// fmovd  fs{TOP-2}, fs{TOP-1}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top - 1), g0, DS(ops_top - 2));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 1, data_type);

    /* duplicate val1 */
    data_type = get_ops_type(ops_top + 1);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP+1}, g0, is{TOP-2}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 2), IS(ops_top + 1), g0);
        break;

      case T_REF:
	// 
	// add  rs{TOP+1}, g0, rs{TOP-2}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 2), RS(ops_top + 1), g0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP+1}, fs{TOP-2}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 2), g0, FS(ops_top + 1));
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 2, data_type);

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP2)
{
    //
    // ..., val2, val1 -> ..., val2, val1, val2, val1
    //
    //     mov {any_type}s{TOP-1}, {any_type}s{TOP+1}
    //     mov {any_type}s{TOP}, {any_type}s{TOP+2}
    //
    InstrNode *c_instr = p_instr;
    VarType data_type;
    
    /* move val2 */
    data_type = get_ops_type(ops_top - 1);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP-1}, g0, is{TOP+1}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top - 1), g0);
        break;

      case T_REF:
	// 
	// add  rs{TOP-1}, g0, rs{TOP+1}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top - 1), g0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP-1}, fs{TOP+1}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top - 1));
        break;

      case T_LONG:
	// 
	// add  ivs{TOP-1}, g0, ivs{TOP+1}
	//
        APPEND_INSTR6(ADD, LS(ops_top + 1), LS(ops_top - 1), g0);
        break;

      case T_DOUBLE:
	// 
	// fmovd  ds{TOP-1}, ds{TOP+1}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DS(ops_top - 1));
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;
    set_ops_type(ops_top + 1, data_type);

    /* move val1 */
    data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	// 
	// add  is{TOP}, g0, is{TOP+2}
	//
        APPEND_INSTR6(ADD, IS(ops_top + 2), IS(ops_top), g0);
        break;

      case T_REF:
	// 
	// add  rs{TOP}, g0, rs{TOP+2}
	//
        APPEND_INSTR6(ADD, RS(ops_top + 2), RS(ops_top), g0);
        break;

      case T_FLOAT:
	// 
	// fmovs  fs{TOP}, fs{TOP+2}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top + 2), g0, FS(ops_top));
        break;

      case T_IVOID:
	// 
	// add  ivs{TOP}, g0, ivs{TOP+2}
	//
	APPEND_INSTR6(ADD, IVS(ops_top + 2), IVS(ops_top), g0);
        break;

      case T_FVOID:
	break;

      default:
        assert(false);
    }

    set_ops_type(ops_top + 2, data_type);

    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP2_X1)
{
    //
    // ..., val3, val2, val1 -> ..., val2, val1, val3, val2, val1
    //
    // val1 and val2 should contain 32-bit data types or be the two
    // words of a single 64-bit datum. val3 should be 32-bit data
    // types.
    //
    InstrNode *c_instr = p_instr;
    VarType data_type;

    data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP}, g0, is{TOP+2}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 2), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP}, g0, rs{TOP+2}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 2), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, fs{TOP+2}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 2), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_IVOID: 
	//
	// add  ivs{TOP}, g0, ivs{TOP+2}
	//
	APPEND_INSTR6(ADD, IVS(ops_top + 2), IVS(ops_top), g0);
	Instr_SetLastUseOfSrc(c_instr, 0);
      case T_FVOID:
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;
    set_ops_type(ops_top + 2, data_type);

    /* move val2 */
    data_type = get_ops_type(ops_top - 1);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-1}, g0, is{TOP+1}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-1}, g0, rs{TOP+1}
	//
        APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-1}, fs{TOP+1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_LONG:
	//
	// add  ls{TOP-1}, g0, ls{TOP+1}
	//
	APPEND_INSTR6(ADD, LS(ops_top + 1), LS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_DOUBLE:
	//
	// fmovd  ds{TOP-1}, ds{TOP+1}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DS(ops_top - 1));
        translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top + 1, data_type);
    
    /* move val3 */
    data_type = get_ops_type(ops_top - 2);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-2}, g0, is{TOP}
	//
        APPEND_INSTR6(ADD, IS(ops_top), IS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-2}, g0, rs{TOP}
	//
        APPEND_INSTR6(ADD, RS(ops_top), RS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-2}, fs{TOP}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top), g0, FS(ops_top - 2));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top, data_type);

    /* duplicate val1 */
    data_type = get_ops_type(ops_top + 2);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP+2}, g0, is{TOP-1}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 1), IS(ops_top + 2), g0);
        break;

      case T_REF:
	//
	// add  rs{TOP+2}, g0, rs{TOP-1}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 1), RS(ops_top + 2), g0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP+2}, rs{TOP-1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 1), g0, FS(ops_top + 2));
        break;

      case T_IVOID: 
	//
	// add  ivs{TOP+2}, g0, ivs{TOP-1}
	//
        APPEND_INSTR6(ADD, IVS(ops_top - 1), IVS(ops_top + 2), g0);
	break;
      case T_FVOID:
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 1, data_type);

    /* duplicate val2 */
    data_type = get_ops_type(ops_top + 1);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP+1}, g0, is{TOP-2}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 2), IS(ops_top + 1), g0);
        break;

      case T_REF:
	//
	// add  rs{TOP+1}, g0, rs{TOP-2}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 2), RS(ops_top + 1), g0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP+1}, fs{TOP-2}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 2), g0, FS(ops_top + 1));
        break;

      case T_LONG:
	//
	// add  ls{TOP+1}, g0, ls{TOP-2}
	//
        APPEND_INSTR6(ADD, LS(ops_top - 2), LS(ops_top + 1), g0);
        break;

      case T_DOUBLE:
	//
	// fmovd  ds{TOP+1}, ds{TOP-2}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top - 2), g0, DS(ops_top + 1));
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 2, data_type);

    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DUP2_X2)
{
    //
    // ..., val4, val3, val2, val1 -> ..., val2, val1, val4, val3, val2, val1
    //
    // val1 and val2 should contain 32-bit data types or be the two
    // words of a single 64-bit datum. val3 and val4 should contain
    // 32-bit data types or be the two words of a single 64-bit datum.
    //
    InstrNode *c_instr = p_instr;
    VarType data_type;

    /* move val1 */
    data_type = get_ops_type(ops_top);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP}, g0, is{TOP+2}
	//
	APPEND_INSTR6(ADD, IS(ops_top + 2), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP}, g0, rs{TOP+2}
	//
	APPEND_INSTR6(ADD, RS(ops_top + 2), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP}, g0, fs{TOP+2}
	//
	APPEND_INSTR6(FMOVS, FS(ops_top + 2), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_IVOID: 
	//
	// add  ivs{TOP}, g0, ivs{TOP+2}
	//
	APPEND_INSTR6(ADD, IVS(ops_top + 2), IVS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
	break;
      case T_FVOID:
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;
    set_ops_type(ops_top + 2, data_type);

    /* move val2 */
    data_type = get_ops_type(ops_top - 1);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-1}, g0, is{TOP+1}
	//
        APPEND_INSTR6(ADD, IS(ops_top + 1), IS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-1}, g0, rs{TOP+1}
	//
        APPEND_INSTR6(ADD, RS(ops_top + 1), RS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-1}, fs{TOP+1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top + 1), g0, FS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_LONG:
	//
	// add  ls{TOP-1}, g0, ls{TOP+1}
	//
        APPEND_INSTR6(ADD, LS(ops_top + 1), LS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_DOUBLE:
	//
	// fmovd  ds{TOP-1}, ds{TOP+1}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top + 1), g0, DS(ops_top - 1));
	translated_instrs[pc] = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top + 1, data_type);

    /* move val3 */
    data_type = get_ops_type(ops_top - 2);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-2}, g0, is{TOP}
	//
        APPEND_INSTR6(ADD, IS(ops_top), IS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-2}, g0, rs{TOP}
	//
        APPEND_INSTR6(ADD, RS(ops_top), RS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-2}, fs{TOP}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top), g0, FS(ops_top - 2));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_IVOID: 
	//
	// add  ivs{TOP-2}, g0, ivs{TOP}
	//
	APPEND_INSTR6(ADD, IVS(ops_top), IVS(ops_top - 2), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
	break;
      case T_FVOID:
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top, data_type);

    /* move val4 */
    data_type = get_ops_type(ops_top - 3);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP-3}, g0, is{TOP-1}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 1), IS(ops_top - 3), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-3}, g0, rs{TOP-1}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 1), RS(ops_top - 3), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-3}, fs{TOP-1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 1), g0, FS(ops_top - 3));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      case T_LONG:
	//
	// add  ls{TOP-3}, g0, ls{TOP-1}
	//
        APPEND_INSTR6(ADD, LS(ops_top - 1), LS(ops_top - 3), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_DOUBLE:
	//
	// fmovd  ds{TOP-3}, ds{TOP-1}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top - 1), g0, DS(ops_top - 3));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 1, data_type);

    /* duplicate val1 */
    data_type = get_ops_type(ops_top + 2);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP+2}, g0, is{TOP-2}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 2), IS(ops_top + 2), g0);
        break;

      case T_REF:
	//
	// add  rs{TOP+2}, g0, rs{TOP-2}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 2), RS(ops_top + 2), g0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP+2}, fs{TOP-2}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 2), g0, FS(ops_top + 2));
        break;

      case T_IVOID: 
	//
	// add  ivs{TOP+2}, g0, ivs{TOP-2}
	//
        APPEND_INSTR6(ADD, IVS(ops_top - 2), IVS(ops_top + 2), g0);
	break;
      case T_FVOID:
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 2, data_type);

    /* duplicate val2 */
    data_type = get_ops_type(ops_top + 1);

    switch (data_type) {
      case T_INT:
	//
	// add  is{TOP+1}, g0, is{TOP-3}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 3), IS(ops_top + 1), g0);
        break;

      case T_REF:
	//
	// add  rs{TOP+1}, g0, rs{TOP-3}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 3), RS(ops_top + 1), g0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP+1}, fs{TOP-3}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 3), g0, FS(ops_top + 1));
        break;

      case T_LONG:
	//
	// add  ls{TOP+1}, g0, ls{TOP-3}
	//
        APPEND_INSTR6(ADD, LS(ops_top - 3), LS(ops_top + 1), g0);
        break;

      case T_DOUBLE:
	//
	// fmovs  ds{TOP+1}, ds{TOP-3}
	//
        APPEND_INSTR6(FMOVD, DS(ops_top - 3), g0, DS(ops_top + 1));
        break;

      default:
        assert(false);
    }

    set_ops_type(ops_top - 3, data_type);

    ops_top += 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(SWAP)
{
    //
    // ..., val2, val1 -> ..., val1, val2
    //
    // val1 and va2 should contain 32-bit data types.
    //
    InstrNode *c_instr = p_instr;
    VarType data_type1 = get_ops_type(ops_top);
    VarType data_type2 = get_ops_type(ops_top - 1);

    /* move val1 to temporary variable */

    switch (data_type1) {
      case T_INT:
	//
	// add  is{TOP}, g0, it0
	//
	APPEND_INSTR6(ADD, IT(0), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  is{TOP}, g0, it0
	//
	APPEND_INSTR6(ADD, RT(0), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	APPEND_INSTR6(FMOVS, FT(0), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    translated_instrs[pc] = c_instr;

    /* move val2 */

    switch (data_type2) {
      case T_INT:
	//
	// add  is{TOP-1}, g0, is{TOP}
	//
        APPEND_INSTR6(ADD, IS(ops_top), IS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  rs{TOP-1}, g0, rs{TOP}
	//
        APPEND_INSTR6(ADD, RS(ops_top), RS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  fs{TOP-1}, fs{TOP}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top), g0, FS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }

    /* move val1 from temporary variable */

    switch (data_type1) {
      case T_INT:
	//
	// add  it0, g0, is{TOP - 1}
	//
        APPEND_INSTR6(ADD, IS(ops_top - 1), IT(0), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_REF:
	//
	// add  at0, g0, rs{TOP - 1}
	//
        APPEND_INSTR6(ADD, RS(ops_top - 1), RT(0), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
        break;

      case T_FLOAT:
	//
	// fmovs  ft0, g0, fs{TOP - 1}
	//
        APPEND_INSTR6(FMOVS, FS(ops_top - 1), g0, FT(0));
        Instr_SetLastUseOfSrc(c_instr, 1);
        break;

      default:
        assert(false);
    }
   
    set_ops_type(ops_top - 1, data_type1);
    set_ops_type(ops_top, data_type2);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(IADD)
{
    //
    // ..., val1, val2 -> ..., val1+val2
    //
    //  add  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);
    assert(get_ops_type(ops_top - 1) == T_INT);

    APPEND_INSTR6(ADD, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LADD)
{
    //
    // ..., long val1, long val2 -> ..., long val+val2
    //
    // addcc  ivs{TOP-2}, ivs{TOP}, ivs{TOP-2}
    // addx   ls{TOP-3}, ls{TOP-1}, ls{TOP-3}
    //============================================================
    //              VLIW ISA
    //============================================================
    // addcc ivs{TOP-2}, ivs{TOP}, ivs{TOP-2}, cc
    // addx  ls{TOP-3}, ls{TOP-1}, cc, ls{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR6(ADDCC, IVS(ops_top - 2), IVS(ops_top - 2), IVS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(ADDX, LS(ops_top - 3), LS(ops_top - 3), LS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);



    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FADD)
{
    //
    // ..., val1, val2 -> ..., val1+val2
    //
    // fadds fs{TOP-1}, fs{TOP}, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);
    
    APPEND_INSTR6(FADDS, FS(ops_top - 1), FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DADD)
{
    //
    // ..., double val1, double 2 -> ..., double val1-val2
    //
    //    faddd ds{TOP-3}, ds{TOP-1}, ds{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FADDD, DS(ops_top - 3), DS(ops_top - 3), DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ISUB)
{
    //
    // ..., val1, val2 -> ..., val1-val2
    //
    //  sub   is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SUB, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSUB)
{
    //
    // ..., long val1, long val2 -> ..., long val-val2
    //
    // subcc ivs{TOP-2}, ivs{TOP}, ivs{TOP-2}
    // subx  ls{TOP-3}, ls{TOP-1}, ls{TOP-3}
    //=============================================================
    //         VLIW ISA
    //=============================================================
    // subcc ivs{TOP-2}, ivs{TOP}, ivs{TOP-2}, cc
    // subx  ls{TOP-3}, ls{TOP-1}, cc, ls{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR6(SUBCC, IVS(ops_top - 2), IVS(ops_top - 2), IVS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SUBX, LS(ops_top - 3), LS(ops_top - 3), LS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);



    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FSUB)
{
    //
    // ..., val1, val2 -> ..., val1+val2
    //
    // fsubs fs{TOP-1}, fs{TOP}, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FSUBS, FS(ops_top - 1), FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DSUB)
{
    //
    // ..., double val1, double 2 -> ..., double val1-val2
    //
    //    fsubd ds{TOP-3}, ds{TOP-1}, ds{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FSUBD, DS(ops_top - 3), DS(ops_top - 3), DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IMUL)
{
    //
    // ..., val1, val2 -> ..., val1*val2
    //
    //  smul   is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SMUL, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LMUL)
{
    //
    // ..., long val1, long val2 -> ..., long val*val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-3}, ivs{TOP-2} -> g1
    // conversion ls{TOP-1}, ivs{TOP}   -> g3
    // mulx       g1, g3, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 3), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-2), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLLX, g3, LS(ops_top - 1), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRL, g4, IVS(ops_top), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);
    APPEND_INSTR6(OR, g3, g3, g4);

    APPEND_INSTR6(MULX, g1, g1, g3);

    APPEND_INSTR6(ADD, IVS(ops_top-2), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-3), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    umul ivs{TOP-2}, ivs{TOP}, it4
    //    rd   %y, it0
    //    smul ivs{TOP-2}, ls{TOP-1}, it1
    //    add  it0, it1, it2
    //    smul ivs{TOP}, ls{TOP-3}, it3
    //    add  it2, it3, ls{TOP-3}
    //    add  it4, g0, ivs{TOP-2}
    //
    InstrNode *c_instr = p_instr;
    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR6(UMUL, IT(4), IVS(ops_top - 2), IVS(ops_top));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(RDY, IT(0), g0, g0);
    APPEND_INSTR6(SMUL, IT(1), IVS(ops_top - 2), LS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(ADD, IT(2), IT(0), IT(1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SMUL, IT(3), IVS(ops_top), LS(ops_top - 3));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(ADD, LS(ops_top -3), IT(2), IT(3));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(ADD, IVS(ops_top - 2), IT(4), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);


#endif /* not USE_64_BIT_INTEGER_REGISTER */

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FMUL)
{
    //
    // ..., float val1, float val2 -> ..., float val1*val2
    //
    // fmuls fs{TOP-1}, fs{TOP}, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FMULS, FS(ops_top - 1), FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DMUL)
{
    //
    // ..., double val1, double 2 -> ..., double val1*val2
    //
    //    fmuld ds{TOP-3}, ds{TOP-1}, ds{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);
    
    APPEND_INSTR6(FMULD, DS(ops_top - 3), DS(ops_top - 3), DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IDIV)
{
    //
    // ..., val1, val2 -> ..., val1/val2
    //
    //    sra   is{TOP-1}, 31, it0
    //    wr    g0, it0, y
    //    sdiv  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);


    APPEND_INSTR5(SRA, IT(0), IS(ops_top - 1), 31);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(WRY, g0, g0, IT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SDIV, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LDIV)
{
    //
    // ..., long val1, long val2 -> ..., long val/val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-3}, ivs{TOP-2} -> g1
    // conversion ls{TOP-1}, ivs{TOP}   -> g3
    // sdivx      g1, g3, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 3), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-2), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLLX, g3, LS(ops_top - 1), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRL, g4, IVS(ops_top), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);
    APPEND_INSTR6(OR, g3, g3, g4);

    APPEND_INSTR6(SDIVX, g1, g1, g3);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    APPEND_INSTR6(ADD, IVS(ops_top-2), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-3), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //   call __divdi3
    //
    // __divdi3 is internal function of gcc
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[4];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR1(CALL, (int) __divdi3);
    translated_instrs[pc] = c_instr;

    arg_vars[0] = LS(ops_top - 3);
    arg_vars[1] = IVS(ops_top - 2);
    arg_vars[2] = LS(ops_top - 1);
    arg_vars[3] = IVS(ops_top);

    ret_vars[0] = LS(ops_top - 3);
    ret_vars[1] = IVS(ops_top - 2);

    CFGGen_process_for_function_call(cfg, c_instr, __divdi3,
				     4, arg_vars, 2, ret_vars);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
#endif /* not USE_64_BIT_INTEGER_REGISTER */

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FDIV)
{
    //
    // ..., val1, val2 -> ..., val1/val2
    //
    // fdivs fs{TOP-1}, fs{TOP}, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FDIVS, FS(ops_top - 1), FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DDIV)
{
    //
    // ..., double val1, double 2 -> ..., double val1/val2
    //
    //    fdivd ds{TOP-3}, ds{TOP-1}, ds{TOP-3}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FDIVD, DS(ops_top - 3), DS(ops_top - 3), DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IREM)
{
    //
    // ..., val1, val2 -> ..., val%val2
    //
    //    sra   is{TOP-1}, 31, it0
    //    wr    g0, it0, y
    //    sdiv  is{TOP-1}, is{TOP}, it1
    //    smul  it1, is{TOP}, it2
    //    sub   is{TOP-1}, it2, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top - 1) == T_INT);


    APPEND_INSTR5(SRA, IT(0), IS(ops_top - 1), 31);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR6(WRY, g0, g0, IT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SDIV, IT(1), IS(ops_top - 1), IS(ops_top));
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    APPEND_INSTR6(SMUL, IT(2), IT(1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SUB, IS(ops_top - 1), IS(ops_top - 1), IT(2));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);


    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LREM)
{
    //
    // ..., long val1, long val2 -> ..., long val%val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-3}, ivs{TOP-2} -> g1
    // conversion ls{TOP-1}, ivs{TOP}   -> g3
    // sdivx      g1, g3, g2
    // mulx       g2, g3, g2
    // sub        g1, g2, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 3), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-2), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLLX, g3, LS(ops_top - 1), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRL, g4, IVS(ops_top), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);
    APPEND_INSTR6(OR, g3, g3, g4);

    APPEND_INSTR6(SDIVX, g2, g1, g3);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    APPEND_INSTR6(MULX, g2, g2, g3);
    APPEND_INSTR6(SUB, g1, g1, g2);

    APPEND_INSTR6(ADD, IVS(ops_top-2), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-3), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    call __moddi3
    //
    // __moddi3 is internal function of gcc
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[4];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR1(CALL, (int) __moddi3);
    translated_instrs[pc] = c_instr;

    arg_vars[0] = LS(ops_top - 3);
    arg_vars[1] = IVS(ops_top - 2);
    arg_vars[2] = LS(ops_top - 1);
    arg_vars[3] = IVS(ops_top);

    ret_vars[0] = LS(ops_top - 3);
    ret_vars[1] = IVS(ops_top - 2);

    CFGGen_process_for_function_call(cfg, c_instr, __moddi3, 
				     4, arg_vars, 2, ret_vars);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
#endif /* not USE_64_BIT_INTEGER_REGISTER */

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FREM)
{
    //
    // ..., float val1, float val2 -> float val1%val2
    //
    // Now I will use the function, 'fmod' in <math.h>. The argument
    // of this function is double, type-conversion must occur. To do
    // this, I will use the stack entries reserved for conversion.
    //
    //       fstod fs{TOP-1}, dt0
    //       fstod fs{TOP}, dt2
    //       call  fmod (o0: dt0, o1: fvt1, o2: dt2, o3: fvt3, ret: dt0, fvt1)
    //       fdtos dt0, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[4];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);

    arg_vars[0] = DT(0);
    arg_vars[1] = FVT(1);
    arg_vars[2] = DT(2);
    arg_vars[3] = FVT(3);

    ret_vars[0] = DT(0);
    ret_vars[1] = FVT(1);

    APPEND_INSTR6(FSTOD, DT(0), g0, FS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(FSTOD, DT(2), g0, FS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR1(CALL, (int) fmod);
    CFGGen_process_for_function_call(cfg, c_instr, fmod, 
				     4, arg_vars, 2, ret_vars);
    APPEND_INSTR6(FDTOS, FS(ops_top - 1), g0, DT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DREM)
{
    //
    // ..., double val1, double val2 -> double val1%val2
    //
    // Now I will use the function, 'fmod' in <math.h>. The argument
    // of this function is double, type-conversion must occur. To do
    // this, I will use the stack entries reserved for conversion.
    //
    //   call fmod (o0: ds{TOP-3}, o1: fvs{TOP-2}, o2: ds{TOP-1}, 
    //              o3: fvs{TOP}, ret: ds{TOP-3}, fvs{TOP-2})
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[4];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR1(CALL, (int) fmod);
    translated_instrs[pc] = c_instr;

    arg_vars[0] = DS(ops_top - 3);
    arg_vars[1] = FVS(ops_top - 2);
    arg_vars[2] = DS(ops_top - 1);
    arg_vars[3] = FVS(ops_top);

    ret_vars[0] = DS(ops_top - 3);
    ret_vars[1] = FVS(ops_top - 2);

    CFGGen_process_for_function_call(cfg, c_instr, fmod, 
				     4, arg_vars, 2, ret_vars);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(INEG)
{
    //
    // ..., val -> ..., -val
    //
    // sub g0, is{TOP}, is{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SUB, IS(ops_top), g0, IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LNEG)
{
    // ..., long val -> ..., long -val
    //
    // subcc g0, ivs{TOP}, ivs{TOP}
    // subx  g0, ls{TOP-1}, ls{TOP-1}
    //==============================================================
    //                VLIW ISA
    //==============================================================
    // subcc g0, ivs{TOP}, ivs{TOP}, cc
    // subx  g0, ls{TOP-1}, cc, ls{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR6(SUBCC, IVS(ops_top), g0, IVS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(SUBX, LS(ops_top - 1), g0, LS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 1);


    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FNEG)
{
    //
    // ..., float val -> ..., float -val
    //
    // fnegs fs{TOP}, fs{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FNEGS, FS(ops_top), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(DNEG)
{
    //
    // ..., double val -> ..., double -val
    //
    // fnegd ds{TOP-1}, ds{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FNEGD, DS(ops_top - 1), g0, DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(ISHL)
{
    //
    // ..., val1, val2 -> ..., val1 << val2
    //
    //  sll  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SLL, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSHL)
{
    //
    // ..., long val1, val2 -> ..., long val1 << val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-2}, ivs{TOP-1} -> g1
    // and        is{TOP}, 0x3f, g3
    // sllx       g1, g3, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 2), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-1), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(AND, g3, IS(ops_top), 0x3f);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);

    APPEND_INSTR6(SLLX, g1, g1, g3);

    APPEND_INSTR6(ADD, IVS(ops_top-1), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-2), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //   and  is{TOP}, 0x3f, it0
    //   call __ashldi3
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[3];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(AND, IT(0), IS(ops_top), 0x3f);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR1(CALL, (int) __ashldi3);

    arg_vars[0] = LS(ops_top - 2);
    arg_vars[1] = IVS(ops_top - 1);
    arg_vars[2] = IT(0);

    ret_vars[0] = LS(ops_top - 2);
    ret_vars[1] = IVS(ops_top - 1);

    CFGGen_process_for_function_call(cfg, c_instr, __ashldi3, 
				     3, arg_vars, 2, ret_vars);

#endif /* not USE_64_BIT_INTEGER_REGISTER */
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ISHR)
{
    //
    // ..., val1, val2 -> ..., val1 >> val2
    //
    // sra is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SRA, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LSHR)
{
    //
    // ..., long val1, val2 -> ..., long val1 >> val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-2}, ivs{TOP-1} -> g1
    // mov        is{TOP}               -> g3 (by srl)
    // srax       g1, g3, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 2), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-1), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(AND, g3, IS(ops_top), 0x3f);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);

    APPEND_INSTR6(SRAX, g1, g1, g3);

    APPEND_INSTR6(ADD, IVS(ops_top-1), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-2), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    AND  is{TOP}, 0x3f, it0
    //    call __ashrdi3
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[3];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(AND, IT(0), IS(ops_top), 0x3f);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR1(CALL, (int) __ashrdi3);

    arg_vars[0] = LS(ops_top - 2);
    arg_vars[1] = IVS(ops_top - 1);
    arg_vars[2] = IT(0);

    ret_vars[0] = LS(ops_top - 2);
    ret_vars[1] = IVS(ops_top - 1);

    CFGGen_process_for_function_call(cfg, c_instr, __ashrdi3, 
				     3, arg_vars, 2, ret_vars);

#endif /* not USE_64_BIT_INTEGER_REGISTER */
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IUSHR)
{
    //
    // ..., val1, val2 -> ..., val1 >> val2
    //
    //  srl  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(SRL, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LUSHR)
{
    //
    // ..., long val1, val2 -> ..., long val1 >> val2
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-2}, ivs{TOP-1} -> g1
    // mov        is{TOP}               -> g3 (by srl)
    // srlx       g1, g3, g1
    // conversion g1 -> ls{TOP-3}, ivs{TOP-2}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 2), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-1), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(AND, g3, IS(ops_top), 0x3f);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);

    APPEND_INSTR6(SRLX, g1, g1, g3);

    APPEND_INSTR6(ADD, IVS(ops_top-1), g1, g0);
    APPEND_INSTR5(SRAX, LS(ops_top-2), g1, 32);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    and  it0, is{TOP}, 0x3f
    //    call __lshrdi3
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[3];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 2) == T_LONG);
    assert(get_ops_type(ops_top - 1) == T_IVOID);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(AND, IT(0), IS(ops_top), 0x3f);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR1(CALL, (int) __lshrdi3);

    arg_vars[0] = LS(ops_top - 2);
    arg_vars[1] = IVS(ops_top -1);
    arg_vars[2] = IT(0);

    ret_vars[0] = LS(ops_top - 2);
    ret_vars[1] = IVS(ops_top - 1);

    CFGGen_process_for_function_call(cfg, c_instr, __lshrdi3, 
				     3, arg_vars, 2, ret_vars);

#endif /* not USE_64_BIT_INTEGER_REGISTER */

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IAND)
{
    //
    // ..., val1, val2 -> ..., val1 & val2
    //
    //  and  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(AND, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LAND)
{
    //
    // ..., long val1, long val2 -> ..., long val1 & val2
    //
    //   and ls{TOP-3}, ls{TOP-1}, ls{TOP-3}
    //   and ivs{TOP-2}, ivs{TOP-2}, ivs{TOP-2}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(AND, LS(ops_top - 3), LS(ops_top - 3), LS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    APPEND_INSTR6(AND, IVS(ops_top - 2), IVS(ops_top - 2), IVS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IOR)
{
    //
    // ..., val1, val2 -> ..., val1 | val2
    //
    //  or  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(OR, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LOR)
{
    //
    // ..., long val1, long val2 -> ..., long val1 | val2
    //
    //   or ls{TOP-3}, ls{TOP-1}, ls{TOP-3}
    //   or ivs{TOP-2}, ivs{TOP-2}, ivs{TOP-2}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(OR, LS(ops_top - 3), LS(ops_top - 3), LS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(OR, IVS(ops_top - 2), IVS(ops_top - 2), IVS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IXOR)
{
    //
    // ..., val1, val2 -> ..., val1 ^ val2
    //
    //  XOR  is{TOP-1}, is{TOP}, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(XOR, IS(ops_top - 1), IS(ops_top - 1), IS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(LXOR)
{
    //
    // ..., long val1, long val2 -> ..., long val1 ^ val2
    //
    //   xor ls{TOP-3}, ls{TOP-1}, ls{TOP-3}
    //   xor ivs{TOP-2}, ivs{TOP-2}, ivs{TOP-2}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR6(XOR, LS(ops_top - 3), LS(ops_top - 3), LS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(XOR, IVS(ops_top - 2), IVS(ops_top - 2), IVS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    ops_top -= 2;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(IINC)
{
    //
    // increment local variable by constant
    //
    //  add il{index}, const, il{index}
    //
    InstrNode *c_instr = p_instr;
    int npc;
    uint32 index;
    int32 const_value;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    
    if (wide) {
        index = (uint32) BCode_get_uint16(bcode + pc + 1);
        const_value = (int32) BCode_get_int16(bcode + pc + 3);

	APPEND_INSTR5(ADD, IL(index), IL(index), const_value);
        wide = false;
        npc = pc + 5;
    } else {
        index = (uint32) BCode_get_uint8(bcode + pc + 1);
        const_value = (int32) BCode_get_int8(bcode + pc + 2);

        APPEND_INSTR5(ADD, IL(index), IL(index), const_value);
        npc = pc + 3;
    }

    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(I2L)
{
    //
    // ..., val -> ..., long val
    //
    //   mov   is{TOP}, ivs{TOP+1}
    //   sra   ivs{TOP+1}, 31, ls{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR6(ADD, IVS(ops_top + 1), IS(ops_top), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRA, LS(ops_top), IVS(ops_top + 1), 31);

    set_ops_type(ops_top, T_LONG);
    set_ops_type(ops_top + 1, T_IVOID);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(I2F)
{
    //
    // ..., val -> ..., float val
    //
    //   st    is{TOP}, [fp-8]
    //   ldf   [fp-8], ft0
    //   fitos ft0, fs{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR8(ST, IS(ops_top), FP, -8);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LDF, FT(0), FP, -8);
    APPEND_INSTR6(FITOS, FS(ops_top), g0, FT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);

    set_ops_type(ops_top, T_FLOAT);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(I2D)
{
    //
    // ..., val -> ..., double val
    //
    //   st    is{TOP}, [fp-8]
    //   ldf   [fp-8], ft0
    //   fitod ft0, ds{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR8(ST, IS(ops_top), FP, -8);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LDF, FT(0), FP, -8);
    APPEND_INSTR6(FITOD, DS(ops_top), g0, FT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);

    set_ops_type(ops_top, T_DOUBLE);
    set_ops_type(ops_top + 1, T_FVOID);
    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(L2I)
{
    //
    // ..., long val -> ..., val
    //
    //   add ls{TOP-1}, g0, g0
    //   add ivs{TOP}, g0, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    // to mark the last use of ls{TOP-1}	
    APPEND_INSTR6(ADD, g0, LS(ops_top - 1), g0);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(ADD, IS(ops_top - 1), IVS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 1, T_INT);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(L2F)
{
    //
    // ..., long val -> ..., float val
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    //    st    ls{TOP-1}, [fp-8]
    //    st    ivs{TOP},  [fp-4]
    //    lddf  [fp-8], dt0
    //    fxtos dt0, fs{TOP-1}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR8(ST, LS(ops_top-1), FP, -8);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(ST, IVS(ops_top), FP, -4);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LDDF, DT(0), FP, -8);
    APPEND_INSTR6(FXTOS, FS(ops_top-1), g0, DT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    call __floatdisf
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[2];
    int ret_vars[1];

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR1(CALL, (int) __floatdisf);
    translated_instrs[pc] = c_instr;

    arg_vars[0] = LS(ops_top - 1);
    arg_vars[1] = IVS(ops_top);

    ret_vars[0] = FS(ops_top - 1);

    CFGGen_process_for_function_call(cfg, c_instr, __floatdisf, 
				     2, arg_vars, 1, ret_vars);

#endif /* not USE_64_BIT_INTEGER_REGISTER */

    set_ops_type(ops_top - 1, T_FLOAT);
    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(L2D)
{
    //
    // ..., long val -> ..., double val
    //
#ifdef USE_64_BIT_INTEGER_REGISTER
    //    st    ls{TOP-1}, [fp-8]
    //    st    ivs{TOP},  [fp-4]
    //    lddf  [fp-8], dt0
    //    fxtod dt0, ds{TOP-1}
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR8(ST, LS(ops_top-1), FP, -8);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(ST, IVS(ops_top), FP, -4);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LDDF, DT(0), FP, -8);
    APPEND_INSTR6(FXTOD, DS(ops_top-1), g0, DT(0));
    Instr_SetLastUseOfSrc(c_instr, 1);

#else /* not USE_64_BIT_INTEGER_REGISTER */
    //    call __floatdidf
    //    (o0: ls{TOP-1}, o1: ivs{TOP}, ret: ds{TOP-1}, fvs{TOP})
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[2];
    int ret_vars[2];

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    APPEND_INSTR1(CALL, (int) __floatdidf);
    translated_instrs[pc] = c_instr;

    arg_vars[0] = LS(ops_top - 1);
    arg_vars[1] = IVS(ops_top);

    ret_vars[0] = DS(ops_top - 1);
    ret_vars[1] = FVS(ops_top);

    CFGGen_process_for_function_call(cfg, c_instr, __floatdidf, 
				     2, arg_vars, 2, ret_vars);

#endif /* not USE_64_BIT_INTEGER_REGISTER */

    set_ops_type(ops_top - 1, T_DOUBLE);
    set_ops_type(ops_top, T_FVOID);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(F2I)
{
    //
    // ..., float val -> ..., val
    //
    //   fstoi fs{TOP}, ft0
    //   stf   ft0, [fp-8]
    //   ld    [fp-8], is{TOP}
    //
    InstrNode *c_instr = p_instr;
    InstrNode **first_instr = &translated_instrs[pc];

    assert(get_ops_type(ops_top) == T_FLOAT);

    /* for correct conversion from floating to integer */
    c_instr = CSeq_create_on_FSR_invalid_trap_instruction(cfg, c_instr, pc, 
							  first_instr);

    APPEND_INSTR6(FSTOI, FT(0), g0, FS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(STF, FT(0), FP, -8);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LD, IS(ops_top), FP, -8);

    c_instr = CSeq_create_off_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							   NULL);

    set_ops_type(ops_top, T_INT);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(F2L)
{
    //
    // ..., float val -> ..., long val
    //
    //    fstox fs{TOP}, dt0
    //    stdf  dt0, [fp-8]
    //    ld    [fp-8], ls{TOP}
    //    ld    [fp-4], ivs{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    InstrNode **first_instr = &translated_instrs[pc];

    assert(get_ops_type(ops_top) == T_FLOAT);

    c_instr = CSeq_create_on_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							  first_instr);

    APPEND_INSTR6(FSTOX, DT(0), g0, FS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(STDF, DT(0), FP, -8);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LD, LS(ops_top), FP, -8);
    APPEND_INSTR5(LD, IVS(ops_top + 1), FP, -4);

    c_instr = CSeq_create_off_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							   NULL);

    set_ops_type(ops_top, T_LONG);
    set_ops_type(ops_top + 1, T_IVOID);

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(F2D)
{
    //
    // ..., float val -> ..., double val
    //
    //     fstod fs{TOP}, ds{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_FLOAT);

    APPEND_INSTR6(FSTOD, DS(ops_top), g0, FS(ops_top));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    set_ops_type(ops_top, T_DOUBLE);
    set_ops_type(ops_top + 1, T_FVOID);

    ops_top++;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(D2I)
{
    //
    // ..., double val -> ..., val
    //
    //   fdtoi ds{TOP-1}, ft0
    //   stf   ft0, [fp-8]
    //   ld    [fp-8], is{TOP-1}
    //
    InstrNode *c_instr = p_instr;
    InstrNode **first_instr = &translated_instrs[pc];

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    c_instr = CSeq_create_on_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							  first_instr);

    APPEND_INSTR6(FDTOI, FT(0), g0, DS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(STF, FT(0), FP, -8);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LD, IS(ops_top - 1), FP, -8);
    c_instr = CSeq_create_off_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							   first_instr);

    set_ops_type(ops_top - 1, T_INT);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(D2L)
{
    //
    // ..., double val -> ..., long val
    //
    //    fdtox ds{TOP-1}, dt0
    //    stdf  dt0, [fp-8]
    //    ld    [fp-8], ls{TOP}
    //    ld    [fp-4], ivs{TOP+1}
    //
    InstrNode *c_instr = p_instr;
    InstrNode **first_instr = &translated_instrs[pc];

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    c_instr = CSeq_create_on_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							  first_instr);

    APPEND_INSTR6(FDTOX, DT(0), g0, DS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR8(STDF, DT(0), FP, -8);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR5(LD, LS(ops_top - 1), FP, -8);
    APPEND_INSTR5(LD, IVS(ops_top), FP, -4);

    c_instr = CSeq_create_off_FSR_invalid_trap_instruction(cfg, c_instr, pc,
							   NULL);

    set_ops_type(ops_top - 1, T_LONG);
    set_ops_type(ops_top, T_IVOID);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(D2F)
{
    //
    // ..., double val -> ..., float val
    //
    //   fdtos ds{TOP-1}, fs{TOP-1}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    APPEND_INSTR6(FDTOS, FS(ops_top - 1), g0, DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 1);

    set_ops_type(ops_top - 1, T_FLOAT);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);

}


translate_instr(INT2BYTE)
{
    //
    // ..., val -> ..., byte val
    //
    //    sll  is{TOP}, 24, it0
    //    sra  it0, 24, is{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 24);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRA, IS(ops_top), IT(0), 24);
    Instr_SetLastUseOfSrc(c_instr, 0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(INT2CHAR)
{
    //
    // ..., val -> ..., char val
    //
    //    sll  is{TOP}, 16, it0
    //    srl  it0, 16, is{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 16);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRL, IS(ops_top), IT(0), 16);
    Instr_SetLastUseOfSrc(c_instr, 0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(INT2SHORT)
{
    //
    // ..., val -> ..., short val
    //
    //    sll  is{TOP}, 16, it0
    //    sra  it0, 16, is{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_INT);

    APPEND_INSTR5(SLL, IT(0), IS(ops_top), 16);
    translated_instrs[pc] = c_instr;
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRA, IS(ops_top), IT(0), 16);
    Instr_SetLastUseOfSrc(c_instr, 0);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}


translate_instr(LCMP)
{
#ifdef USE_64_BIT_INTEGER_REGISTER
    // conversion ls{TOP-3}, ivs{TOP-2} -> g1
    // conversion ls{TOP-1}, ivs{TOP}   -> g2
    // subcc      g1, g2, g1
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    InstrNode *end_instr;

    uint8 *binfo;
    uint8 *bcode;
    byte next_opcode;
    int npc;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    binfo = Method_GetBcodeInfo(method);
    bcode = Method_GetByteCode(method);
    npc = pc + 1;
    next_opcode = BCode_get_uint8(bcode + npc);

    APPEND_INSTR5(SLLX, g1, LS(ops_top - 3), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(SRL, g2, IVS(ops_top-2), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SLLX, g3, LS(ops_top - 1), 32);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(SRL, g4, IVS(ops_top), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR6(OR, g1, g1, g2);
    APPEND_INSTR6(OR, g3, g3, g4);

    APPEND_INSTR6(SUBCC, g0, g1, g3);

    if (!is_bytecode_join(binfo, npc)
        && BCode_is_if_cond_bytecode(next_opcode)) {
        // use local lookahead
        int16 offset;

        offset = BCode_get_int16(bcode + npc + 1);
        pc = npc;

        switch (next_opcode) {
          case IFEQ: APPEND_INSTR3(BE|USE_XCC); break;
          case IFNE: APPEND_INSTR3(BNE|USE_XCC); break;
          case IFLT: APPEND_INSTR3(BL|USE_XCC); break;
          case IFGE: APPEND_INSTR3(BGE|USE_XCC); break;
          case IFGT: APPEND_INSTR3(BG|USE_XCC); break;
          case IFLE: APPEND_INSTR3(BLE|USE_XCC); break;
        }
        CFGGen_process_for_branch(cfg, c_instr);
        
        ops_top -= 4;

        have_multi_successors = true;

        PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

        PROCESS_AND_VERIFY_FOR_NPC(npc + 3);

        return; 
    }

    // normal case
    APPEND_INSTR3(BG|USE_XCC);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1);

    APPEND_INSTR3(BL|USE_XCC);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1);

    APPEND_INSTR5(ADD, IS(ops_top-3), g0, 0);
    end_instr = c_instr;

    c_instr = branch_instr1;
    APPEND_INSTR5(ADD, IS(ops_top-3), g0, 1);
    Instr_connect_instruction(c_instr, end_instr);

    c_instr = branch_instr2;
    APPEND_INSTR5(ADD, IS(ops_top-3), g0, -1);
    Instr_connect_instruction(c_instr, end_instr);

    c_instr = end_instr;
#else /* not USE_64_BIT_INTEGER_REGISTER */
    //
    // ..., long val1, long val2 -> ..., 1|0|-1
    //
    //   subcc ls{TOP-3}, ls{TOP-1}, g0
    //   bg    WRITE_1
    //   bl    WRITE_M1
    //   subcc vs{TOP-2}, vs{TOP}, g0
    //   bgu   WRITE_1
    //   bcs   WRITE_M1
    // WRITE_0:
    //   add   g0, 0, it0
    //   b     END
    // WRITE_1:
    //   add   g0, 1, it0
    //   b     END
    // WRITE_M1:
    //   add   g0, -1, it0
    // END:
    //   add   ls{TOP-3}, ls{TOP-1}, g0
    //   add   vs{TOP-2}, vs{TOP}, g0
    //   add   it0, g0, is{TOP-3}
    //=============================================================
    //       VLIW ISA
    //=============================================================
    //   sg    ls{TOP-3}, ls{TOP-1}, cc
    //   jset  cc, WRITE_1
    //   sl    ls{TOP-3}, ls{TOP-1}, cc
    //   jset  cc, WRITE_M1
    //   sgu   vs{TOP-2}, vs{TOP}, cc
    //   jset  cc, WRITE_1
    //   scs   vs{TOP-2}, vs{TOP}, cc
    //   jset  cc, WRITE_M1
    // WRITE_0:
    //   add   g0, 0, it0
    //   b     END
    // WRITE_1:
    //   add   g0, 1, it0
    //   b     END
    // WRITE_M1:
    //   add   g0, -1, it0
    // END:
    //   add   ls{TOP-3}, ls{TOP-1}, g0
    //   add   vs{TOP-2}, vs{TOP}, g0
    //   add   it0, g0, is{TOP-3}
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    InstrNode *branch_instr3;
    InstrNode *branch_instr4;
    InstrNode *write_0;
    InstrNode *write_1;

    assert(get_ops_type(ops_top - 3) == T_LONG);
    assert(get_ops_type(ops_top - 2) == T_IVOID);
    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);


    APPEND_INSTR6(SUBCC, g0, LS(ops_top - 3), LS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR3(BG);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1); // bg WRITE_1
    APPEND_INSTR3(BL);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr2); // bl WRITE_M1
    APPEND_INSTR6(SUBCC, g0, IVS(ops_top - 2), IVS(ops_top));
    APPEND_INSTR3(BGU);
    branch_instr3 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr3); // bg WRITE_1
    APPEND_INSTR3(BCS);
    branch_instr4 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr4); // bl WRITE_M1


    // WRITE_0:
    c_instr = branch_instr4;
    APPEND_INSTR5(ADD, IT(0), g0, 0);
    write_0 = c_instr;

    // WRITE_1:
    c_instr = branch_instr1;
    APPEND_INSTR5(ADD, IT(0), g0, 1);
    write_1 = c_instr;
    Instr_connect_instruction(branch_instr3, write_1);

    // WRITE_M1:
    c_instr = branch_instr2;
    APPEND_INSTR5(ADD, IT(0), g0, -1);
    Instr_connect_instruction(branch_instr4, c_instr);

    // END:
    APPEND_INSTR6(ADD, g0, LS(ops_top - 3), LS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    Instr_connect_instruction(write_0, c_instr);
    Instr_connect_instruction(write_1, c_instr);

    APPEND_INSTR6(ADD, g0, IVS(ops_top - 2), IVS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(ADD, IS(ops_top - 3), IT(0), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

#endif /* not USE_64_BIT_INTEGER_REGISTER */

    ops_top -= 3;

    set_ops_type(ops_top, T_INT);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(FCMPL)
{
    //
    // ..., float val1, float val2 -> ..., result
    //
    // If either val1 or val2 is NaN, result is -1.
    //
    //    fcmps  fs{TOP-1}, fs{TOP}
    //    add    g0, 1, it0
    //    fbg    END
    //    fcmps  fs{TOP-1}, fs{TOP}
    //    add    g0, -1, it0
    //    fbul   END
    //    add    g0, 0, it0
    // END:
    //    add    fs{TOP-1}, fs{TOP}, g0
    //    add    it0, g0, is{TOP-1}
    //=============================================================
    //       VLIW ISA
    //=============================================================
    //    fsbgs  fs{TOP-1}, fs{TOP}, cc
    //    add    g0, 1, it0
    //    jset   cc, END
    //    fsuls  fs{TOP-1}, fs{TOP}, cc
    //    add    g0, -1, it0
    //    jset   cc, END
    //    add    g0, 0, it0
    //  END:
    //    add    fs{TOP-1}, fs{TOP}, g0
    //    add    it0, g0, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    uint8 *binfo;
    
    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);


    binfo = Method_GetBcodeInfo(method);
    /* if next instruction is branch and is not a join point, we can
       branch on floating point conditional register not on integer
       conditional register. */
    if (!is_bytecode_join(binfo, pc + 1)) {
	int npc;
	byte opcode;
	uint8 *bcode;

	npc = pc + 1;
	bcode = Method_GetByteCode(method);
	opcode = BCode_get_uint8(bcode + npc);

	if (opcode == IFEQ || opcode == IFNE || opcode == IFLT
	    || opcode == IFGE || opcode == IFGT || opcode == IFLE) {
	    /* optimized case */
	    int16 offset;

	    offset = BCode_get_int16(bcode + npc + 1);

	    APPEND_NOP();
	    translated_instrs[pc] = c_instr;
	    INSERT_DEBUG_CODE();

	    APPEND_INSTR6(FCMPS, g0, FS(ops_top - 1), FS(ops_top));
	    Instr_SetLastUseOfSrc(c_instr, 0);
	    Instr_SetLastUseOfSrc(c_instr, 1);

	    pc = npc;
            // larger 1
            // equal 0
            // less or unordered -1
            switch(opcode){
	      case IFEQ:
		APPEND_INSTR3(FBE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFNE:
		APPEND_INSTR3(FBNE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFLT:
		APPEND_INSTR3(FBUL);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFGE:
		APPEND_INSTR3(FBGE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFGT:
		APPEND_INSTR3(FBG);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFLE:
		APPEND_INSTR3(FBULE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

              default: 
		assert(false);
            }

            ops_top -= 2;

            have_multi_successors = true;

            PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

            PROCESS_AND_VERIFY_FOR_NPC(npc + 3);

            return;
	}
    }

    APPEND_INSTR6(FCMPS, g0, FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IT(0), g0, 1);
    APPEND_INSTR3(FBG);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1); // fbg END
    APPEND_INSTR5(ADD, IT(0), g0, -1);
    APPEND_INSTR3(FBUL);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr2); // fbul END
    APPEND_INSTR5(ADD, IT(0), g0, 0);

	
    // END:      make fs{TOP-1} and fs{TOP} dead
    APPEND_INSTR6(ADD, g0, FS(ops_top - 1), FS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    Instr_connect_instruction(branch_instr1, c_instr);
    Instr_connect_instruction(branch_instr2, c_instr);

    APPEND_INSTR6(ADD, IS(ops_top - 1), IT(0), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 1, T_INT);

    ops_top--;
	    
    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}




translate_instr(FCMPG)
{
    //
    // ..., float val1, float val2 -> ..., result
    //
    // If either val1 or val2 is NaN, result is 1.
    //
    //    fcmps  fs{TOP-1}, fs{TOP}
    //    add    g0, 1, it0
    //    fbug   END
    //    fcmps  fs{TOP-1}, fs{TOP} -> not needed 
    //    add    g0, -1, it0
    //    fbl   END
    //    add    g0, 0, it0
    // END:
    //    add    fs{TOP-1}, fs{TOP}, g0
    //    add    it0, g0, is{TOP-1}
    //============================================================
    //        VLIW ISA
    //============================================================
    //    fsugs  fs{TOP-1}, fs{TOP}, cc
    //    add    g0, 1, it0
    //    jset   cc, END
    //    fsls   fs{TOP-1}, fs{TOP}, cc
    //    add    g0, -1, it0
    //    jset   cc, END
    //    add    g0, 0, it0
    //  END:
    //    add    fs{TOP-1}, fs{TOP}, g0
    //    add    it0, g0, is{TOP-1}
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    uint8 *binfo;
    
    assert(get_ops_type(ops_top - 1) == T_FLOAT);
    assert(get_ops_type(ops_top) == T_FLOAT);


    binfo = Method_GetBcodeInfo(method);
    /* if next instruction is branch and is not a join point, we can
       branch on floating point conditional register not on integer
       conditional register. */
    if (!is_bytecode_join(binfo, pc + 1)) {
	int npc;
	byte opcode;
	uint8 *bcode;

	npc = pc + 1;
	bcode = Method_GetByteCode(method);
	opcode = BCode_get_uint8(bcode + npc);

	if (opcode == IFEQ || opcode == IFNE || opcode == IFLT
	    || opcode == IFGE || opcode == IFGT || opcode == IFLE) {
	    /* optimized case */
	    int16 offset;

	    offset = BCode_get_int16(bcode + npc + 1);

	    APPEND_NOP();
            translated_instrs[pc] = c_instr;
	    INSERT_DEBUG_CODE();

	    APPEND_INSTR6(FCMPS, g0, FS(ops_top - 1), FS(ops_top));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);

            // larger or unordered 1
            // equal 0
            // less -1
            switch(opcode){
	      case IFEQ:
		APPEND_INSTR3(FBE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
              case IFNE:
		APPEND_INSTR3(FBNE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFLT:
		APPEND_INSTR3(FBL);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFGE:
		APPEND_INSTR3(FBUGE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFGT:
		APPEND_INSTR3(FBUG);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFLE:
		APPEND_INSTR3(FBLE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

              default: assert(0);
            }

            ops_top-=2;

            have_multi_successors = true;

            PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

            PROCESS_AND_VERIFY_FOR_NPC(npc + 3);

            return;
        }
    }

    APPEND_INSTR6(FCMPS, g0, FS(ops_top - 1), FS(ops_top));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IT(0), g0, 1);
    APPEND_INSTR3(FBUG);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1); // fbug END
    APPEND_INSTR5(ADD, IT(0), g0, -1);
    APPEND_INSTR3(FBL);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr2); // fbl END
    APPEND_INSTR5(ADD, IT(0), g0, 0);


    // END:	make fs{TOP-1} and fs{TOP} dead
    APPEND_INSTR6(ADD, g0, FS(ops_top - 1), FS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    Instr_connect_instruction(branch_instr1, c_instr);
    Instr_connect_instruction(branch_instr2, c_instr);

    APPEND_INSTR6(ADD, IS(ops_top - 1), IT(0), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 1, T_INT);

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}




translate_instr(DCMPL)
{
    //
    // ..., double val1, double val2 -> ..., result
    //
    // If either val1 or val2 is NaN, result is -1.
    //
    //    fcmpd  ds{TOP-3}, ds{TOP-1}
    //    add    g0, 1, it0
    //    fbg    END
    //    fcmpd  ds{TOP-3}, ds{TOP-1} -> not needded
    //    add    g0, -1, it0
    //    fbul   END
    //    add    g0, 0, it0
    // END:
    //    add    ds{TOP-3}, ds{TOP-1}, g0 <- indicate that their last use
    //                                    <- will be deleted at phase 3
    //    add    it0, g0, is{TOP-3}
    //===================================================================
    //        VLIW ISA
    //===================================================================
    //    fsbgd  ds{TOP-3}, ds{TOP-1}, cc
    //    add    g0, 1, it0
    //    jset   cc, END
    //    fsuld  ds{TOP-3}, ds{TOP-1}, cc
    //    add    g0, -1, it0
    //    jset   cc, END
    //    add    g0, 0, it0
    //  END:
    //    add    ds{TOP-3}, ds{TOP-1}, g0
    //    add    it0, g0, is{TOP-3}
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    uint8 *binfo;
    
    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);


    binfo = Method_GetBcodeInfo(method);
    if (!is_bytecode_join(binfo, pc + 1)) {
	int npc;
	byte opcode;
	uint8 *bcode;

	npc = pc + 1;
	bcode = Method_GetByteCode(method);
	opcode = BCode_get_uint8(bcode + npc);

	if (opcode == IFEQ || opcode == IFNE || opcode == IFLT
	    || opcode == IFGE || opcode == IFGT || opcode == IFLE) {
	    /* optimized case */
	    int16 offset;

	    offset = BCode_get_int16(bcode + npc + 1);

	    APPEND_NOP();
            translated_instrs[pc] = c_instr;
	    APPEND_INSTR6(FCMPD, g0, DS(ops_top - 3), DS(ops_top - 1));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            // larger 1
            // equal 0
            // less or unordered -1
            switch(opcode){
	      case IFEQ:
		APPEND_INSTR3(FBE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFNE:
		APPEND_INSTR3(FBNE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFLT:
		APPEND_INSTR3(FBUL);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFGE:
		APPEND_INSTR3(FBGE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFGT:
		APPEND_INSTR3(FBG);
                CFGGen_process_for_branch(cfg, c_instr);
                break;
		
	      case IFLE:
		APPEND_INSTR3(FBULE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

              default: assert(0);
            }
            ops_top -= 4;

            have_multi_successors = true;

            PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

            PROCESS_AND_VERIFY_FOR_NPC(npc + 3);

            return;
        }
    }

    APPEND_INSTR6(FCMPD, g0, DS(ops_top - 3), DS(ops_top -1));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IT(0), g0, 1);
    APPEND_INSTR3(FBG);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1); // fbg END
    APPEND_INSTR5(ADD, IT(0), g0, -1);
    APPEND_INSTR3(FBUL);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr2); // fbul END
    APPEND_INSTR5(ADD, IT(0), g0, 0);


    // END:	make ds{TOP-3} and ds{TOP-1} dead
    APPEND_INSTR6(ADD, g0, DS(ops_top -3), DS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    Instr_connect_instruction(branch_instr1, c_instr);
    Instr_connect_instruction(branch_instr2, c_instr);

    APPEND_INSTR6(ADD, IS(ops_top - 3), IT(0), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 3, T_INT);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}



translate_instr(DCMPG)
{
    //
    // ..., double val1, double val2 -> ..., result
    //
    // If either val1 or val2 is NaN, result is 1.
    //
    //    fcmpd  ds{TOP-3}, ds{TOP-1}
    //    add    g0, 1, it0
    //    fbug   END
    //    fcmpd  ds{TOP-3}, ds{TOP-1}
    //    add    g0, -1, it0
    //    fbl    END
    //    add    g0, 0, it0
    // END:
    //    add    ds{TOP-3}, ds{TOP-1}, g0
    //    add    it0, g0, is{TOP-1}
    //============================================================
    //        VLIW ISA
    //============================================================
    //    fsugd  ds{TOP-3}, ds{TOP-1}, cc
    //    add    g0, 1, it0
    //    jset   cc, END
    //    fsld   ds{TOP-3}, fs{TOP-1}, cc
    //    add    g0, -1, it0
    //    jset   cc, END
    //    add    g0, 0, it0
    //  END:
    //    add    ds{TOP-3}, fs{TOP-1}, g0
    //    add    it0, g0, is{TOP-1}
    //
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1;
    InstrNode *branch_instr2;
    uint8 *binfo;
    
    assert(get_ops_type(ops_top - 3) == T_DOUBLE);
    assert(get_ops_type(ops_top - 2) == T_FVOID);
    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);


    binfo = Method_GetBcodeInfo(method);
    if (!is_bytecode_join(binfo, pc + 1)){
	int npc;
	byte opcode;
	uint8 *bcode;

	npc = pc + 1;
	bcode = Method_GetByteCode(method);
	opcode = BCode_get_uint8(bcode + npc);

	if (opcode == IFEQ || opcode == IFNE || opcode == IFLT
	    || opcode == IFGE || opcode == IFGT || opcode == IFLE) {
	    /* optimized case */
	    int16 offset;

	    offset = BCode_get_int16(bcode + npc + 1);

	    APPEND_NOP();
            translated_instrs[pc] = c_instr;
	    APPEND_INSTR6(FCMPD, g0, DS(ops_top - 3), DS(ops_top - 1));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);

            // larger or unordered 1
            // equal 0
            // less -1
            switch(opcode){
	      case IFEQ:
		APPEND_INSTR3(FBE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

 	      case IFNE:
		APPEND_INSTR3(FBNE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFLT:
		APPEND_INSTR3(FBL);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFGE:
		APPEND_INSTR3(FBUGE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFGT:
		APPEND_INSTR3(FBUG);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      case IFLE:
		APPEND_INSTR3(FBLE);
                CFGGen_process_for_branch(cfg, c_instr);
                break;

	      default:
		assert(0);
            }

            ops_top-=4;

            have_multi_successors = true;

            PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

            PROCESS_AND_VERIFY_FOR_NPC(npc + 3);

            return;
        }
    }

    APPEND_INSTR6(FCMPD, g0, DS(ops_top - 3), DS(ops_top - 1));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(ADD, IT(0), g0, 1);
    APPEND_INSTR3(FBUG);
    branch_instr1 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr1); // fbug END
    APPEND_INSTR5(ADD, IT(0), g0, -1);
    APPEND_INSTR3(FBL);
    branch_instr2 = c_instr;
    CFGGen_process_for_branch(cfg, branch_instr2); // fbl END
    APPEND_INSTR5(ADD, IT(0), g0, 0);


    // END:	make ds{TOP-3} and ds{TOP-1} dead
    APPEND_INSTR6(ADD, g0, DS(ops_top - 3), DS(ops_top - 1));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);

    Instr_connect_instruction(branch_instr1, c_instr);
    Instr_connect_instruction(branch_instr2, c_instr);

    APPEND_INSTR6(ADD, IS(ops_top - 3), IT(0), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    set_ops_type(ops_top - 3, T_INT);

    ops_top -= 3;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}



translate_instr(IFEQ)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    be      SUCC2
    // SUCC1:
    //============================================================
    //      VLIW ISA
    //============================================================
    //    se     IS{TOP}, g0, cc
    //    jset   cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    /* Because the CFG is traversed in DFS order, the first pushed
       successor becomes the second successor. Therefore, they should
       be swapped. */

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFNE)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    bne      SUCC2
    // SUCC1:
    //=============================================================
    //      VLIW ISA
    //=============================================================
    //    sne     is{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC2:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BNE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFLT)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    bl      SUCC2
    // SUCC1:
    //============================================================
    //      VLIW ISA
    //============================================================
    //    sl      is{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BL);
    CFGGen_process_for_branch(cfg, c_instr);



    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFGE)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    bge      SUCC2
    // SUCC1:
    //===============================================================
    //        VLIW ISA
    //===============================================================
    //    sge     is{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BGE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFGT)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    bg      SUCC2
    // SUCC1:
    //================================================================
    //       VLIW ISA
    //================================================================
    //    sg      is{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BG);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFLE)
{
    //
    // ..., val -> ...
    //
    //    subcc   is{TOP}, g0, g0
    //    ble     SUCC2
    // SUCC1:
    //=================================================================
    //         VLIW ISA
    //=================================================================
    //    sle     is{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BLE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPEQ)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    be    SUCC2
    // SUCC1:
    //=====================================================================
    //          VLIW ISA
    //=====================================================================
    //    se    is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPNE)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    bne   SUCC2
    // SUCC1:
    //===================================================================
    //           VLIW ISA
    //===================================================================
    //    sne   is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;

    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BNE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPLT)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    bl    SUCC2
    // SUCC1:
    //=====================================================================
    //              VLIW ISA
    //=====================================================================
    //    sl    is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BL);
    CFGGen_process_for_branch(cfg, c_instr);



    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPGE)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    bge   SUCC2
    // SUCC1:
    //============================================================
    //          VLIW ISA
    //============================================================
    //    sge   is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BGE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPGT)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    bg    SUCC2
    // SUCC1:
    //==============================================================
    //            VLIW ISA
    //==============================================================
    //    sg    is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BG);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ICMPLE)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc is{TOP-1}, is{TOP}, g0
    //    ble   SUCC2
    // SUCC1:
    //=================================================================
    //            VLIW ISA
    //=================================================================
    //    sle   is{TOP-1}, is{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_INT);
    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, IS(ops_top - 1), IS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BLE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ACMPEQ)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc rs{TOP-1}, rs{TOP}, g0
    //    be    SUCC2
    // SUCC1:
    //===============================================================
    //           VLIW ISA
    //===============================================================
    //    se    rs{TOP-1}, rs{TOP}, cc
    //    jset  cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_REF);
    assert(get_ops_type(ops_top) == T_REF);

    bcode = Method_GetByteCode(method);

    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, RS(ops_top - 1), RS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IF_ACMPNE)
{
    //
    // ..., val1, val2 -> ...
    //
    //    subcc rs{TOP-1}, rs{TOP}, g0
    //    bne   SUCC2
    // SUCC1:
    //=============================================================
    //          VLIW ISA
    //=============================================================
    //    sne  rs{TOP-1}, rs{TOP}, cc
    //    jset cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    assert(get_ops_type(ops_top - 1) == T_REF);
    assert(get_ops_type(ops_top) == T_REF);

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, RS(ops_top - 1), RS(ops_top));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR3(BNE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top -= 2;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}



translate_instr(GOTO)
{
    //
    // ... -> ...
    //
    // The branch instruction is generated later at actual code
    // generation. Here we only need to connect control flow of CFG.
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;
    
    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int16(bcode + pc +1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(GOTO_W)
{
    //
    // ... -> ...
    //
    // The branch instruction is generated later at actual code
    // generation. Here we only need to connect control flow of CFG.
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int32 offset;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    
    offset = BCode_get_int32(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(TABLESWITCH)
{
    //
    //  ..., index -> ...
    //
    //  if (low >= 0xfffff000 && low <= 0xfff) {
    //      sub   is{TOP}, low, it0
    //  } else {
    //      sethi %hi(low), it1
    //      or    it1, %lo(low), it2
    //      sub   is{TOP}, it2, it0
    //  }
    //===============================================================
    //  if (high - low >= 0xfffff000 && high - low <= 0xfff) {
    //      subcc it0, high - low, g0
    //  } else {
    //      sethi %hi(high - low), it1
    //      or    it1, %lo(high - low), it2
    //      subcc it0, it2, g0
    //  }
    //      bgu   DEFAULT
    //===============================================================
    //               VLIW ISA
    //===============================================================
    //  if (high - low >= 0xfffff000 && high - log <= 0xfff) {
    //      sgu    it0, high - low, cc
    //  } else {
    //      sethi  %hi(high - low), it1
    //      or     it1, %lo(high - low), it2
    //      sgu    it0, it2, cc
    //  }
    //      jset   cc, DEFAULT
    //===============================================================
    //      sethi  %hi(jumptable), it1
    //      or     it1, %lo(jumptable), rt2
    //      sll    it0, 2, it3
    //      ld     [rt2+it3], rt4
    //      jmpl   rt4, g0, g0
    //
    //  DEFAULT:
    //      add    it0, g0, g0     <- it0's last use
    //
    // jumptable: (in data segment)
    //   ...
    //
    // Because of limitation of immediate field, we made two version
    // one of which is using only one instruction with immediate
    // field, the other is using a temporary register for calculating.
    //
    InstrNode *c_instr = p_instr;
    int npc;

    int32 low, high;
    int data_offset;

    int i;

    int jump_table_size;
    int *jump_table;
    int num_of_dests;
    int *dest_list;
    int jump_table_offset_in_data_segment;

    uint8 *bcode;

    InstrNode *branch_instr;
    InstrNode *jump_instr;
    
    assert(get_ops_type(ops_top) == T_INT);

    data_offset = (pc + 4) & -4;	// take into accout padding

    bcode = Method_GetByteCode(method);
    low = BCode_get_int32(bcode + data_offset + 4);
    high = BCode_get_int32(bcode + data_offset + 8);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    if (low >= MIN_SIMM13 && low <= MAX_SIMM13) {
	APPEND_INSTR5(SUB, IT(0), IS(ops_top), low);
        Instr_SetLastUseOfSrc(c_instr, 0);
    } else {
	APPEND_INSTR2(SETHI, IT(1), HI(low));
        APPEND_INSTR5(OR, IT(2), IT(1), LO(low));
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR6(SUB, IT(0), IS(ops_top), IT(2));
        Instr_SetLastUseOfSrc(c_instr, 0);
        Instr_SetLastUseOfSrc(c_instr, 1);
    }


    if (high - low >= MIN_SIMM13 && high - low <= MAX_SIMM13) {
	APPEND_INSTR5(SUBCC, g0, IT(0), high - low);
    } else {
	APPEND_INSTR2(SETHI, IT(1), HI(high - low));
	APPEND_INSTR5(OR, IT(2), IT(1), LO(high - low));
	Instr_SetLastUseOfSrc(c_instr, 0);
	APPEND_INSTR6(SUBCC, g0, IT(0), IT(2));
	Instr_SetLastUseOfSrc(c_instr, 1);
    }

    APPEND_INSTR3(BGU);
    branch_instr = c_instr;
    CFGGen_process_for_branch(cfg, c_instr); // bgu DEFAULT


    /* create jump table in data segment : Until the actual native
       codes are generated, the contents of the jump table can not be
       determined. Therefore, some mechanism should be used for
       resolving. A data entry structure contains the pointer to the
       instruction node of `jmpl' by which the control is
       transferred. At the phase 4, the jump table in the data segment
       should be initialized referring to this pointer. The first
       successor of the pointed 'jmpl' instruction becomes the first
       entry of the jump table, and so on.  Therefore, the successors
       should be pushed onto the stack in the reverse order. */
    jump_table_size = high - low + 1;
    jump_table = (int *) FMA_calloc((jump_table_size + 1) * sizeof(void*));
    num_of_dests = 0;
    dest_list = (int *) FMA_calloc(jump_table_size * sizeof(int));
    jump_table_offset_in_data_segment =
        CFG_AddNewDataEntry(cfg, JUMP_TABLE,
			    jump_table_size * sizeof(InstrNode *),
			    (void *) jump_table,
			    ALIGN_WORD);

    APPEND_INSTR2(SETHI, IT(1), HI(jump_table_offset_in_data_segment));
    add_new_resolve_instr(cfg, c_instr, 
			  (void *) jump_table_offset_in_data_segment);
    APPEND_INSTR5(OR, RT(2), IT(1), LO(jump_table_offset_in_data_segment));
    Instr_SetLastUseOfSrc(c_instr, 0);
    add_new_resolve_instr(cfg, c_instr, 
			  (void*) jump_table_offset_in_data_segment);
    APPEND_INSTR5(SLL, IT(3), IT(0), 2);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR4(LD, RT(4), RT(2), IT(3));
    Instr_SetLastUseOfSrc(c_instr, 0);
    Instr_SetLastUseOfSrc(c_instr, 1);
    APPEND_INSTR6(JMPL, g0, RT(4), g0);
    jump_instr = c_instr;
    Instr_SetLastUseOfSrc(jump_instr, 0);

    jump_table[0] = (int) jump_instr;

    have_multi_successors = true;

    ops_top--;

    c_instr = branch_instr;

    /* On the path of DEFAULT, it0 is already dead. For register
       allocation, it0 is marked dead with nop operation. */
    APPEND_INSTR5(ADD, g0, IT(0), 0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    npc = pc + BCode_get_int32(bcode + data_offset);
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    //
    // set up jump table
    //
    // The successors are pushed in the reverse order.
    //
    c_instr = jump_instr;

    //
    // check unique destinations
    //
    for(i = 0; i < jump_table_size; i++) {
        int j;
        int32 offset;

        offset = BCode_get_int32(bcode + data_offset + 12 + i * 4);

        for(j = 0; j < num_of_dests; j++) {
            if (dest_list[j] == offset) {
                break;
            }
        }

        if (j == num_of_dests) { // new destination
            dest_list[num_of_dests++] = offset;
        }

        jump_table[i + 1] = (int) j;
    }

    for (i = num_of_dests - 1; i >= 0; i--) {
        npc = pc + dest_list[i];

        PROCESS_AND_VERIFY_FOR_NPC(npc);
    }
}

translate_instr(LOOKUPSWITCH)
{
    //
    // ..., key -> ...
    //
    // In bytecode, the keys are in increase order, so that we can use
    // binary search to find a match.
    //
    // The layout of lookup table in data segment is:
    //   keys(npairs)   |  targets(npairs)
    // Therefore the size in bytes is "npairs * 8".
    //
    // it0: npairs, rt1: &(keys array), rt2: &(targets array)
    //
    // if (npairs <= MAX_SIMM13) {
    //     add   g0, npair, it0
    // } else {
    //     sethi %hi(npair), it3
    //     or    it3, %lo(npair), it0
    // }
    //     sethi %hi(lookup_table), it4       <- to resolve
    //     or    it4, %lo(lookup_table), rt1  <- to resolve
    //
    //     call  RT_bin_search (o0: rt1, o1: it0, o2: is{TOP}, ret: it3)
    //===================================================================
    //     subcc it3, g0, g0
    //     bl    DEFAULT
    //===================================================================
    //             VLIW ISA
    //===================================================================
    //     sl    it3, g0, cc
    //     jset  cc, DEFAULT
    //===================================================================
    //     sethi %hi(target_list), it1
    //     or    it1, %lo(target_list), rt2
    //     sll   it3, 2, it4
    //     ld    [rt2+it4], rt5
    //     jmpl  rt5, g0, g0
    // DEFAULT:
    //     add   it3, g0, g0   <- it3 is now dead in this path.
    //
    InstrNode *c_instr = p_instr;
    int npc;

    int data_addr;
    int32 num_of_pairs;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_INT);

    data_addr = (pc + 4) & -4;

    bcode = Method_GetByteCode(method);
    
    num_of_pairs = BCode_get_int32(bcode + data_addr + 4);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    ops_top--;
    have_multi_successors = true;

    c_instr = CSeq_create_lookupswitch_code(cfg, c_instr, pc,
                                            ops_top, num_of_pairs,
                                            bcode + data_addr + 8);
    // last use marking for stack top
    APPEND_INSTR6(ADD, g0, IS(ops_top+1), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);

    // process default target instruction
    npc = pc + BCode_get_int32(bcode + data_addr);
    PROCESS_AND_VERIFY_FOR_NPC(npc);

#if 0
    int lookup_table_size;	// size in bytes
    int *lookup_table;
    int num_of_dests;
    int *dest_list;
    int lookup_table_offset;
    int target_list_offset;
    InstrNode **target_list;
    int i; 

    InstrNode *branch_instr;
    InstrNode *jump_instr;

    int arg_vars[3];
    int ret_vars[1];

    /* if the number of pair is less than 3, it might be better to use
       a few branches than to use binary search. */
    if (num_of_pairs <= 3){
        int i;
	int32 key, dest;

        ops_top--;
        have_multi_successors = true;

        for(i = 0 ; i < num_of_pairs ; i++){
            key = BCode_get_int32(bcode + data_addr + 8 + i * 8);
            dest = pc + BCode_get_int32(bcode + data_addr + 12 + i * 8);

            if (key >= MIN_SIMM13 && key <=  MAX_SIMM13){
                APPEND_INSTR5(SUBCC, g0, IS(ops_top + 1), key);
            } else {
                APPEND_INSTR2(SETHI, IT(0), HI(key));
                APPEND_INSTR5(OR, IT(1), IT(0), LO(key));
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR6(SUBCC, g0, IS(ops_top + 1), IT(1));
                Instr_SetLastUseOfSrc(c_instr, 1);
            }
            APPEND_INSTR3(BE);
            CFGGen_process_for_branch(cfg, c_instr);
            have_multi_successors = true;
            
            PROCESS_AND_VERIFY_FOR_NPC(dest);
        } 
        
        // default path
        APPEND_INSTR6(ADD, g0, IS(ops_top + 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        npc = pc + BCode_get_int32(bcode + data_addr);
        PROCESS_AND_VERIFY_FOR_NPC(npc);
    } else {
	/* using binary search function to find destination */
        if (num_of_pairs <= MAX_SIMM13) {
	    APPEND_INSTR5(ADD, IT(0), g0, num_of_pairs);
        } else {
	    APPEND_INSTR2(SETHI, IT(3), HI(num_of_pairs));
            APPEND_INSTR5(OR, IT(0), IT(3), LO(num_of_pairs));
            Instr_SetLastUseOfSrc(c_instr, 0);
        }
	
	/* now IT(0) contains number of pairs */

        assert(num_of_pairs > 0);

        //
        // setup lookup table
        //
        lookup_table_size = num_of_pairs * 8;

        lookup_table = (int *) FMA_calloc(lookup_table_size + sizeof(void *));
        num_of_dests = 0;
        dest_list = (int *) FMA_calloc(num_of_pairs * sizeof(int));

        lookup_table_offset =
            CFG_AddNewDataEntry(cfg, LOOKUP_TABLE,
				lookup_table_size,
				(void*) lookup_table,
				ALIGN_WORD);

        // A list of keys are first at lookup table.
        for (i = 0; i < num_of_pairs; i++) {
            lookup_table[i] = BCode_get_int32(bcode + data_addr + 8 + i * 8);
        }
        target_list = (InstrNode **)(lookup_table + num_of_pairs);
        target_list_offset = lookup_table_offset + num_of_pairs * 4;

        APPEND_INSTR2(SETHI, IT(4), HI(lookup_table_offset));
        add_new_resolve_instr(cfg, c_instr, (void *) lookup_table_offset);
        APPEND_INSTR5(OR, RT(1), IT(4), 
		      LO(lookup_table_offset));
        Instr_SetLastUseOfSrc(c_instr, 0);
        add_new_resolve_instr(cfg, c_instr, (void *) lookup_table_offset);
	
	/* now rt1 contains the address of lookup table. */

        //
        // use 'RT_bin_search' function
        //
        arg_vars[0] = RT(1);
        arg_vars[1] = IT(0);
        arg_vars[2] = IS(ops_top);
        ret_vars[0] = IT(3);

        APPEND_INSTR1(CALL, (int) RT_bin_search);
        CFGGen_process_for_function_call(cfg, c_instr, RT_bin_search, 
					 3, arg_vars, 1, ret_vars);



        APPEND_INSTR6(SUBCC, g0, IT(3), g0);
	branch_instr = register_format3_instruction(cfg, c_instr, pc, BL);
	CFGGen_process_for_branch(cfg, branch_instr); // bl DEFAULT


	c_instr = branch_instr;
	APPEND_INSTR2(SETHI, IT(1), HI(target_list_offset));
        add_new_resolve_instr(cfg, c_instr, (void*) target_list_offset);
        APPEND_INSTR5(OR, RT(2), IT(1), LO(target_list_offset));
        Instr_SetLastUseOfSrc(c_instr, 0);
        add_new_resolve_instr(cfg, c_instr, (void*) target_list_offset);

	/* rt2 now contains the address of target lists */

        APPEND_INSTR5(SLL, IT(4), IT(3), 2);
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR4(LD, RT(5), RT(2), IT(4));
        Instr_SetLastUseOfSrc(c_instr, 0);
        Instr_SetLastUseOfSrc(c_instr, 1);
	APPEND_INSTR6(JMPL, g0, RT(5), g0);
	jump_instr = c_instr;
        Instr_SetLastUseOfSrc(c_instr, 0);

        have_multi_successors = true;

        ops_top--;

        //
        // DEFAULT:
        //
	c_instr = branch_instr;
        APPEND_INSTR6(ADD, g0, IT(3), g0);	/* make it3 dead */
        Instr_SetLastUseOfSrc(c_instr, 0);

        npc = pc + BCode_get_int32(bcode + data_addr);
        PROCESS_AND_VERIFY_FOR_NPC(npc);

        //
        // set up jump table
        //
        // for easiness of implementation, the jump targets are all nops.
        //
        c_instr = jump_instr;

        target_list[0] = jump_instr;	
	// The actual values of target list can be set with
        // jump_instr's successors.


        //
        // check unique destinations
        //
        for(i = 0; i < num_of_pairs; i++) {
            int j;
            int32 offset;

            offset = BCode_get_int32(bcode + data_addr + 12 + i * 8);

            for(j = 0; j < num_of_dests; j++) {
                if (dest_list[j] == offset) {
                    break;
                }
            }

            if (j == num_of_dests) { // new destination
                dest_list[num_of_dests++] = offset;
            }

            target_list[ i + 1 ] = (void *) j;
        }

        for (i = num_of_dests - 1; i >= 0; i--) {
            npc = pc + dest_list[i];
            PROCESS_AND_VERIFY_FOR_NPC(npc);
        }
    }
#endif 0
}

/* There are 3 kinds of return.
   1. normal return
   	return value : i0, i1 register or f0, f1 register
   	control : transfered to caller function with jmpl instruction
	register window : unwound with restore instruction
   2. inlined method return
   	return value : passed to pseudo register which will be register
		       allocated later.
	control : control flow is connected to caller method
	register window : nothing happen to register window
   3. inlined exception handler return
   	return value : passed to pseudo register which will be register
	               allocated as predefined later.
	control : transfered to caller function with call instruction
	register window : nothing happen to register window
	* note * : in this case ret_addr and ret_stack_top value
	           should be set properly.  */
translate_instr(IRETURN)
{
    //
    // ..., val -> [empty]
    //
    InstrNode *c_instr = p_instr;
    int ret_vars[1];

    assert(get_ops_type(ops_top) == T_INT);

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc, 
						 &translated_instrs[pc],
						 method);
    INSERT_DEBUG_CODE();
    
    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl    iret, 8, g0 (i0: is{TOP})
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);

	    ret_vars[0] = IS(ops_top);

	    CFGGen_process_for_return(cfg, c_instr, 1, ret_vars);
        } else {
	    //
	    // inlined exception handler exit
	    //
	    // add   is{TOP}, g0, is{orgTOP}
	    // call  return_addr
	    //
            int org_stack_offset = ret_stack_top - Var_offset_of_stack_var;

            APPEND_INSTR6(ADD, IS(org_stack_offset), IS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
	// add is{TOP}, g0, is{orgTOP}
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
        int org_stack_offset = IG_GetStackTop(CFGGen_current_ig_node)
	    - Var_offset_of_stack_var;

        APPEND_INSTR6(ADD, IS(org_stack_offset), IS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

translate_instr(LRETURN)
{
    //
    // ..., long val -> [empty]
    //
    //
    InstrNode *c_instr = p_instr;
    int ret_vars[2];

    assert(get_ops_type(ops_top - 1) == T_LONG);
    assert(get_ops_type(ops_top) == T_IVOID);

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc, 
						 &translated_instrs[pc],
						 method);
    
    INSERT_DEBUG_CODE();

    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl    iret, 8 g0 (i0: ls{TOP-1}, i1: ivs{TOP})
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);

	    ret_vars[0] = LS(ops_top - 1);
	    ret_vars[1] = IVS(ops_top);

            CFGGen_process_for_return(cfg, c_instr, 2, ret_vars);
        } else {
	    //
            // inlined exception handler exit.
	    //
	    // add  ls{TOP-1}, g0, ls{orgTOP - 1}
	    // add  ivs{TOP}, g0, ivs{ortTOP}
	    //
            int org_stack_offset = ret_stack_top - Var_offset_of_stack_var;

            APPEND_INSTR6(ADD, LS(org_stack_offset - 1), LS(ops_top - 1), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR6(ADD, IVS(org_stack_offset), IVS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
	// add  ls{TOP-1}, g0, ls{orgTOP}
	// add  ivs{TOP}, g0, ivs{orgTOP+1}
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
        int org_stack_offset = IG_GetStackTop(CFGGen_current_ig_node)
            - Var_offset_of_stack_var;

        APPEND_INSTR6(ADD, LS(org_stack_offset), LS(ops_top - 1), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);
	APPEND_INSTR6(ADD, IVS(org_stack_offset + 1), IVS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

translate_instr(FRETURN)
{
    //
    // ..., float val -> [empty]
    //
    InstrNode *c_instr = p_instr;
    int ret_vars[1];

    assert(get_ops_type(ops_top) == T_FLOAT);

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc,
						 &translated_instrs[pc],
						 method);
    
    INSERT_DEBUG_CODE();

    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl     iret, 8, g0 (f0: fs{TOP})
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);

	    ret_vars[0] = FS(ops_top);

            CFGGen_process_for_return(cfg, c_instr, 1, ret_vars);
        } else {
	    //
	    // inlined exception handler exit
	    //
	    // fmovs  fs{TOP}, g0, fs{orgTOP}
	    // call   return_addr
	    //
            int org_stack_offset = ret_stack_top - Var_offset_of_stack_var;

            APPEND_INSTR6(FMOVS, FS(org_stack_offset), g0, FS(ops_top));
            Instr_SetLastUseOfSrc(c_instr, 1);
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
	// fmovs  fs{TOP}, fs{orgTOP}
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
        int org_stack_offset = IG_GetStackTop(CFGGen_current_ig_node) 
            - Var_offset_of_stack_var;

        APPEND_INSTR6(FMOVS, FS(org_stack_offset), g0, FS(ops_top));
        Instr_SetLastUseOfSrc(c_instr, 1);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

translate_instr(DRETURN)
{
    //
    // ..., double val -> [empty]
    //
    InstrNode *c_instr = p_instr;
    int ret_vars[2];

    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
    assert(get_ops_type(ops_top) == T_FVOID);

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc, 
						 &translated_instrs[pc],
						 method);
    INSERT_DEBUG_CODE();

    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl    iret, 8, g0 (f0: ds{TOP-1}, f1: fvs{TOP})
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);

	    ret_vars[0] = DS(ops_top - 1);
	    ret_vars[1] = FVS(ops_top);

            CFGGen_process_for_return(cfg, c_instr, 2, ret_vars);
        } else {
	    //
	    // inlined exception handler exit
	    //
	    // fmovd  ds{TOP-1}, ds{orgTOP}
	    //
            int org_stack_offset = ret_stack_top - Var_offset_of_stack_var;

            APPEND_INSTR6(FMOVD, DS(org_stack_offset), g0, DS(ops_top - 1));
            Instr_SetLastUseOfSrc(c_instr, 1);
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
	// fmovd  ds{TOP-1}, ds{orgTOP}
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
        int org_stack_offset = IG_GetStackTop(CFGGen_current_ig_node)
	    - Var_offset_of_stack_var;

        APPEND_INSTR6(FMOVD, DS(org_stack_offset), g0, DS(ops_top - 1));
        Instr_SetLastUseOfSrc(c_instr, 1);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

translate_instr(ARETURN)
{
    //
    // ..., ref val -> [empty]
    //
    InstrNode *c_instr = p_instr;
    int ret_vars[1];

    assert(get_ops_type(ops_top) == T_REF);

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc, 
						 &translated_instrs[pc],
						 method);

    INSERT_DEBUG_CODE();

    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl    iret, 8, g0 (i0: rs{TOP})
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);

	    ret_vars[0] = RS(ops_top);

            CFGGen_process_for_return(cfg, c_instr, 1, ret_vars);
        } else {
	    //
	    // inlined exception handler exit
	    //
	    // add   rs{TOP}, g0, rs{orgTOP}
	    // call   return_addr
	    //
            int org_stack_offset = ret_stack_top - Var_offset_of_stack_var;

            APPEND_INSTR6(ADD, RS(org_stack_offset), RS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
	// add  rs{TOP}, rs{orgTOP}
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
        int org_stack_offset = IG_GetStackTop(CFGGen_current_ig_node) 
            - Var_offset_of_stack_var;

        APPEND_INSTR6(ADD, RS(org_stack_offset), RS(ops_top), g0);
        Instr_SetLastUseOfSrc(c_instr, 0);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

translate_instr(RETURN)
{
    //
    // ... -> [empty]
    //
    InstrNode *c_instr = p_instr;

    c_instr = CSeq_create_function_epilogue_code(cfg, c_instr, pc, 
						 &translated_instrs[pc],
						 method);

    INSERT_DEBUG_CODE();

    if (IG_GetDepth(CFGGen_current_ig_node) == 0) {
        if (ret_addr == 0) {
	    //
            // normal main flow exit.
	    //
	    // jmpl    iret, 8, g0 (no return)
	    //
            APPEND_INSTR5(JMPL, g0, IRET, 8);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFGGen_process_for_return(cfg, c_instr, 0, NULL);
        } else {
	    //
            // inlined exception handler exit.
	    //
	    // call  return_addr
	    //
            APPEND_INSTR1(CALL, (int) ret_addr);
            add_new_resolve_instr(cfg, c_instr, ret_addr);
            Instr_SetExceptionReturn(c_instr);
        }
    } else {
	//
	// inlined method exit
	//
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);

	APPEND_NOP();

        Instr_connect_instruction(c_instr, e_instr);
    }
}


translate_instr(GETSTATIC)
{
    //
    // ... -> ..., val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *sfield_class;
    Field *static_field;
    void *sfaddr;
    uint8 *bcode;
    accessFlags access;
    
    bcode = Method_GetByteCode(method);
    index = BCode_get_uint16(bcode + pc + 1);

    // get the information about the indexed static field
    static_field = getField(index, true, method, &sfield_class);
    access = Field_GetAccessFlags(static_field);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    
    // Now the state of 'sfield_class' which contains the field as a member
    // may be CSTATE_LINKED where the class initializer has not executed.
    if (Class_GetState(sfield_class) != CSTATE_OK) {
#ifdef WRONG_CLASSLOADING
        if (!PList_find(uninitialized_class_list, sfield_class)) {
            uninitialized_class_list =
                PList_insert(uninitialized_class_list, sfield_class);
        }
#else /* not WRONG_CLASSLOADING */
        c_instr = CSeq_create_process_class_code(cfg, c_instr, pc, NULL,
						 sfield_class);
#endif /* not WRONG_CLASSLOADING */
    }

    // obtain address of the field in memory
    // assume that the class object cannot move in memory.
    sfaddr = (void *) Field_GetStaticAddr(static_field);

    if (Field_IsReference(static_field)) {
	//
	// sethi  %hi(sfaddr), rt0
	// ld     [rt0+%lo(sfaddr)], rs{TOP+1}
	//
        APPEND_INSTR2(SETHI, RT(0),HI(sfaddr));
        APPEND_INSTR5(LD, RS(ops_top + 1), RT(0), LO(sfaddr));
        Instr_SetLastUseOfSrc(c_instr, 0);
        if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);
	
        set_ops_type(ops_top + 1, T_REF);
        ops_top++;
    } else {
	// static field is primitive type.
        APPEND_INSTR2(SETHI, RT(0), HI(sfaddr));

        switch(Class_GetPrimarySignature(Field_GetType(static_field))) {
          case 'I':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // ld     [rt0+%lo(sfaddr)], is{TOP+1}
	    //
            APPEND_INSTR5(LD, IS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

	    set_ops_type(ops_top + 1, T_INT);
	    ops_top++;
	    break;

          case 'Z':
          case 'B':
	    //
	    // sethi  %hi(sfaddr), rt0
            // ldsb   [rt0+%lo(sfaddr)], is{TOP+1}
	    //
	    APPEND_INSTR5(LDSB, IS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

	    set_ops_type(ops_top + 1, T_INT);
	    ops_top++;
	    break;

          case 'S':
	    //
	    // sethi  %hi(sfaddr), rt0
            // ldsh   [rt0+%lo(sfaddr)], is{TOP+1}
	    //
	    APPEND_INSTR5(LDSH, IS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

	    set_ops_type(ops_top + 1, T_INT);
	    ops_top++;
	    break;

          case 'C':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // lduh   [rt0+%lo(sfaddr)], is{TOP+1}
	    //
            APPEND_INSTR5(LDUH, IS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

            set_ops_type(ops_top + 1, T_INT);
            ops_top++;
            break;

          case 'F':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // ldf    [rt0+%lo(sfaddr)], fs{TOP+1}
	    //
            APPEND_INSTR5(LDF, FS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

            set_ops_type(ops_top + 1, T_FLOAT);
            ops_top++;
            break;

          case 'J':
	    if (HI(sfaddr) == HI(sfaddr + 4)) {
		//
		// sethi  %hi(sfaddr), rt0
		// ld     [rt0+%lo(sfaddr)], ls{TOP+1}
		// ld     [rt0+%lo(sfaddr+4)], ivs{TOP+2}
		//
		APPEND_INSTR5(LD, LS(ops_top + 1), RT(0), LO(sfaddr));
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);
		APPEND_INSTR5(LD, IVS(ops_top + 2), RT(0), LO(sfaddr + 4));
		Instr_SetLastUseOfSrc(c_instr, 0);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);
	    } else {
		//
		// sethi  %hi(sfaddr), rt0
		// ld     [rt0+%lo(sfaddr)], ls{TOP+1}
		// sethi  %hi(sfaddr+4), rt0
		// ld     [rt0+%lo(sfaddr+4)], ivs{TOP+2}
		//
		APPEND_INSTR5(LD, LS(ops_top + 1), RT(0), LO(sfaddr));
		Instr_SetLastUseOfSrc(c_instr, 0);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);
		APPEND_INSTR2(SETHI, RT(0), HI(sfaddr));
		APPEND_INSTR5(LD, IVS(ops_top + 2), RT(0), LO(sfaddr + 4));
		Instr_SetLastUseOfSrc(c_instr, 0);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);
	    }

            set_ops_type(ops_top + 1, T_LONG);
            set_ops_type(ops_top + 2, T_IVOID);
            ops_top += 2;
            break;

          case 'D':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // lddf   [rt0+%lo(sfaddr)], ds{TOP+1}
	    //
            APPEND_INSTR5(LDDF, DS(ops_top + 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
        Instr_SetFieldInfo(c_instr, static_field);

            set_ops_type(ops_top + 1, T_DOUBLE);
            set_ops_type(ops_top + 2, T_FVOID);
            ops_top += 2;
            break;

          default:
            assert(false);
        }
    }

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(PUTSTATIC)
{
    //
    // ..., val -> ...
    //
    InstrNode *c_instr = p_instr;
    uint32 index;
    Hjava_lang_Class *sfield_class;
    Field *static_field;
    void *sfaddr;
    uint8 *bcode;
    accessFlags access;

    bcode = Method_GetByteCode(method);
    index = BCode_get_uint16(bcode + pc + 1);

    // get the information about the indexed static field
    static_field = getField(index, true, method, &sfield_class);
    access = Field_GetAccessFlags(static_field);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    
    // Now the state of 'sfield_class' which contains the field as a member
    // may be CSTATE_LINKED where the class initializer has not executed.
    if (Class_GetState(sfield_class) != CSTATE_OK) {
#ifdef WRONG_CLASSLOADING
        if (!PList_find(uninitialized_class_list, sfield_class)) {
            uninitialized_class_list =
                PList_insert(uninitialized_class_list, sfield_class);
        }
#else /* not WRONG_CLASSLOADING */
        c_instr = CSeq_create_process_class_code(cfg, c_instr, pc, NULL,
						 sfield_class);
#endif /* not WRONG_CLASSLOADING */
    }

    // obtain address of the field in memory
    // assume that the class object cannot move in memory.
    sfaddr = (void *) Field_GetStaticAddr(static_field);

    if (Field_IsReference(static_field)) {
        //
        // sethi  %hi(sfaddr), rt0
        // st   rs{TOP}, [rt0+%lo(sfaddr)]
        //
        APPEND_INSTR2(SETHI, RT(0), HI(sfaddr));
        APPEND_INSTR8(ST, RS(ops_top), RT(0), LO(sfaddr));
        Instr_SetLastUseOfSrc(c_instr, 0);
        Instr_SetLastUseOfSrc(c_instr, 1);
	if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

        ops_top--;
    } else {
	// static field is primitive type.
        APPEND_INSTR2(SETHI, RT(0), HI(sfaddr));

        switch (Class_GetPrimarySignature(Field_GetType(static_field))) {
          case 'I':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // st     is{TOP}, [rt0+%lo(sfaddr)]
	    //
            APPEND_INSTR8(ST, IS(ops_top), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

            ops_top--;
            break;

          case 'Z':
          case 'B':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // stb    is{TOP}, [rt0+%lo(sfaddr)]
	    //
            APPEND_INSTR8(STB, IS(ops_top), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

            ops_top--;
            break;

          case 'S':
          case 'C':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // sth    is{TOP}, [rt0+%lo(sfaddr)]
	    //
            APPEND_INSTR8(STH, IS(ops_top), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

            ops_top--;
            break;

          case 'F':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // stf    fs{TOP}, [rt0+%lo(sfaddr)]
	    //
            APPEND_INSTR8(STF, FS(ops_top), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

            ops_top--;
            break;

          case 'J':
	    if (HI(sfaddr) == HI(sfaddr + 4)) {
		//
		// sethi  %hi(sfaddr), rt0
		// st     ls{TOP-1}, [rt0+%lo(sfaddr)]
		// st     ivs{TOP}, [rt0+%lo(sfaddr+4)]
		//
		APPEND_INSTR8(ST, LS(ops_top - 1), RT(0), LO(sfaddr));
		Instr_SetLastUseOfSrc(c_instr, 1);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

		APPEND_INSTR8(ST, IVS(ops_top),RT(0), LO(sfaddr + 4));
		Instr_SetLastUseOfSrc(c_instr, 0);
		Instr_SetLastUseOfSrc(c_instr, 1);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);
	    } else {
		//
		// sethi  %hi(sfaddr), rt0
		// st     ls{TOP-1}, [rt0+%lo(sfaddr)]
		// sethi  %hi(sfaddr+4), rt0
		// st     ivs{TOP}, [rt0+%lo(sfaddr+4)]
		//
		APPEND_INSTR8(ST, LS(ops_top - 1), RT(0), LO(sfaddr));
		Instr_SetLastUseOfSrc(c_instr, 1);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);
		APPEND_INSTR2(SETHI, RT(0), HI(sfaddr + 4));
		APPEND_INSTR8(ST, IVS(ops_top),RT(0), LO(sfaddr + 4));
		Instr_SetLastUseOfSrc(c_instr, 0);
		Instr_SetLastUseOfSrc(c_instr, 1);
		if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);
	    }

            ops_top -= 2;
            break;

          case 'D':
	    //
	    // sethi  %hi(sfaddr), rt0
	    // stdf ds{TOP-1}, [rt0+%lo(sfaddr)]
	    //
            APPEND_INSTR8(STDF, DS(ops_top - 1), RT(0), LO(sfaddr));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, static_field);

            ops_top -= 2;
            break;

          default:
            assert(false);
        }
    }

    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(GETFIELD)
{
    //
    // ..., obj ref -> ..., val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *field_class;
    Field *field;
    int foffset; 
    uint8 *bcode;
    accessFlags access;

    bcode = Method_GetByteCode(method);
    index = BCode_get_uint16(bcode + pc + 1);

    // get the information about the indexed field The state of
    // field_class must be CSTATE_OK when this instruction executes.
    field = getField(index, false, method, &field_class);
    access = Field_GetAccessFlags(field);

    // obtain field offset in object
    foffset = Field_GetOffset(field);

    assert(get_ops_type(ops_top) == T_REF);

    if (Field_IsReference(field)) {
	//
	// ld [rs{TOP}+foffset], rs{TOP}
	//
        APPEND_INSTR5(LD, RS(ops_top), RS(ops_top), foffset);
        Instr_SetLastUseOfSrc(c_instr, 0);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
        translated_instrs[pc] = c_instr;
	if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

        set_ops_type(ops_top,T_REF);
    } else {
	// static field is primitive type.
        switch (Class_GetPrimarySignature(Field_GetType(field))) {
	  case 'I':
	    //
            // ld [rs{TOP}+foffset], is{TOP}
	    //
            APPEND_INSTR5(LD, IS(ops_top),RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            set_ops_type(ops_top, T_INT);
	    break;

          case 'Z':
	  case 'B':
	    //
            // ldsb [rs{TOP}+foffset], is{TOP}
	    //
            APPEND_INSTR5(LDSB, IS(ops_top), RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            set_ops_type(ops_top, T_INT);
	    break;

	  case 'S':
	    //
            // ldsh [rs{TOP}+foffset], is{TOP}
	    //
            APPEND_INSTR5(LDSH, IS(ops_top), RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            set_ops_type(ops_top, T_INT);
	    break;

	  case 'C':
	    //
            // lduh [rs{TOP}+foffset], is{TOP}
	    //
            APPEND_INSTR5(LDUH, IS(ops_top), RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            set_ops_type(ops_top, T_INT);
	    break;

	  case 'F':
	    //
            // ldf [rs{TOP}+foffset], fs{TOP}
	    //
            APPEND_INSTR5(LDF, FS(ops_top), RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            set_ops_type(ops_top, T_FLOAT);
            break;

	  case 'J':
	    //
	    // add rs{TOP}, g0, rt0
            // ld  [rt0+foffset], ls{TOP}
            // ld  [rt0+foffset+4], ivs{TOP+1}
	    //
	    /* additional copy need because of register allocation */
	    APPEND_INSTR6(ADD, RT(0), RS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            translated_instrs[pc] = c_instr;
            APPEND_INSTR5(LD, LS(ops_top), RT(0), foffset);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);
            APPEND_INSTR5(LD, IVS(ops_top + 1), RT(0), foffset + 4);
            Instr_SetLastUseOfSrc(c_instr, 0);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            set_ops_type(ops_top, T_LONG);
            set_ops_type(ops_top + 1, T_IVOID);
            ops_top++;
            break;

	  case 'D':
	    //
            // lddf [rs{TOP}+foffset], ds{TOP}
	    //
            APPEND_INSTR5(LDDF, DS(ops_top), RS(ops_top), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
            translated_instrs[pc] = c_instr;
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            set_ops_type(ops_top, T_DOUBLE);
            set_ops_type(ops_top + 1, T_FVOID);

            ops_top++;
            break;

          default:
            assert(false);
        }
    }

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(PUTFIELD)
{
    //
    // ..., obj-ref, val -> ...
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *field_class;
    Field *field;
    int foffset;
    uint8 *bcode;
    accessFlags access;

    bcode = Method_GetByteCode(method);
    index = BCode_get_uint16(bcode + pc + 1);

    // get the information about the indexed field The state of
    // field_class must be CSTATE_OK when this instruction executes.
    field = getField(index, false, method, &field_class);
    access = Field_GetAccessFlags(field);

    // obtain field offset in object
    foffset = Field_GetOffset(field);

    if (Field_IsReference(field)) {
	//
	// st  rs{TOP}, [rs{TOP}+foffset]
	//
	assert(get_ops_type(ops_top - 1) == T_REF);
	assert(get_ops_type(ops_top) == T_REF);

        APPEND_INSTR8(ST, RS(ops_top), RS(ops_top - 1), foffset);
        Instr_SetLastUseOfSrc(c_instr, 0);
        Instr_SetLastUseOfSrc(c_instr, 1);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

        translated_instrs[pc] = c_instr;

        ops_top -= 2;
    } else {
	// static field is primitive type.
        switch (Class_GetPrimarySignature(Field_GetType(field))) {
 	  case 'I':
	    //
	    // st  is{TOP}, [rs{TOP-1}+foffset]
	    //
	    assert(get_ops_type(ops_top - 1) == T_REF);
	    assert(get_ops_type(ops_top) == T_INT);

	    APPEND_INSTR8(ST, IS(ops_top), RS(ops_top - 1), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

	    ops_top -= 2;
	    break;

          case 'Z':
          case 'B':
	    //
	    // stb  is{TOP}, [rs{TOP-1}+foffset]
	    //
	    assert(get_ops_type(ops_top - 1) == T_REF);
	    assert(get_ops_type(ops_top) == T_INT);

            APPEND_INSTR8(STB, IS(ops_top), RS(ops_top - 1), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

	    ops_top -= 2;
	    break;

          case 'S':
          case 'C':
	    //
	    // sth  is{TOP}, [rs{TOP-1}+foffset]
	    //
	    assert(get_ops_type(ops_top - 1) == T_REF);
	    assert(get_ops_type(ops_top) == T_INT);

            APPEND_INSTR8(STH, IS(ops_top), RS(ops_top - 1), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

	    ops_top -= 2;
	    break;

          case 'F':
	    //
	    // stf  fs{TOP}, [rs{TOP-1}+foffset]
	    //
	    assert(get_ops_type(ops_top - 1) == T_REF);
	    assert(get_ops_type(ops_top) == T_FLOAT);

	    APPEND_INSTR8(STF, FS(ops_top), RS(ops_top - 1), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            ops_top -= 2;
            break;

          case 'J':
	    //
	    // st   ls{TOP-1}, [rs{TOP-2}+foffset]
            // st   ivs{TOP}, [rs{TOP-2}+foffset+4]
	    //
	    assert(get_ops_type(ops_top - 2) == T_REF);
	    assert(get_ops_type(ops_top - 1) == T_LONG);
	    assert(get_ops_type(ops_top) == T_IVOID);

            APPEND_INSTR8(ST, LS(ops_top - 1), RS(ops_top - 2), foffset);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            APPEND_INSTR8(ST, IVS(ops_top), RS(ops_top - 2), foffset + 4);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            ops_top -= 3;
            break;

          case 'D':
	    //
            // stdf   ds{TOP-1}, [rs{TOP-2}+foffset]
	    //
	    assert(get_ops_type(ops_top - 2) == T_REF);
	    assert(get_ops_type(ops_top - 1) == T_DOUBLE);
	    assert(get_ops_type(ops_top) == T_FVOID);
	    
	    APPEND_INSTR8(STDF, DS(ops_top - 1), RS(ops_top - 2), foffset);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
	    if (access & ACC_VOLATILE) Instr_SetVolatile(c_instr);
    Instr_SetFieldInfo(c_instr, field);

            translated_instrs[pc] = c_instr;

            ops_top -= 3;
            break;

          default:
            assert(false);
        }
    }

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(INVOKEVIRTUAL)
{
    //
    // ..., obj ref, ...args... -> ..., return val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    int arg_size;
    Method *called_method;
    FuncInfo *info;
    int ret_ops_top;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    // get method index in constant pool
    index = BCode_get_uint16(bcode + pc + 1);

    // get indexed method information
    called_method = Method_GetReferredMethod(method, index);

    // The called method should not be "<init>" or "<clinit>".
    // If the method is protected, then it must be either a member of the
    // current class and the class of objref must be either the current
    // class or a subclass of the current class.
    // For efficiency, the checking is not done here.
    // Someday this checking must be implemented.

    // The information is only from signature.
    // It does not consider the implicit 'this' reference.
    arg_size = Method_GetArgSize(called_method);
    CFG_UpdateNumOfMaxArgs(cfg, arg_size + 1);

    ret_ops_top = ops_top - (arg_size+1);
    info = Instr_make_func_info(called_method, ops_top, arg_size+1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();

    if (flag_call_stat) {
        c_instr = CSeq_create_call_stat_code(cfg, c_instr, called_method, pc);
    }

#ifdef TYPE_ANALYSIS
    if (flag_type_analysis) {
        //Type analysis is done after phase2.
        //Approapriate invocation type is determined during type analysis
        c_instr = CSeq_create_pseudo_invoke_code(cfg, c_instr, pc,
                                                 called_method, 
                                                 InvokeVirtualType,
                                                 info, ret_ops_top);
    } else 
#endif /* TYPE_ANALYSIS */
    {
    bool    need_null_check = true;
    bool    resolved = false;
    int     meth_idx = called_method->idx + DTABLE_METHODINDEX;

    if (called_method->accflags & (ACC_FINAL|ACC_PRIVATE))
	resolved = true;
        
    c_instr = 
	CSeq_make_corresponding_invoke_sequence(cfg, c_instr, pc,
						called_method,
						ret_ops_top,
						NULL,
						NULL, info,
						meth_idx,
						need_null_check,
						resolved);
    }
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}


translate_instr(INVOKESPECIAL)
{
    //
    // ..., obj ref, ...args... -> ..., return val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    short arg_size;
    Method *called_method;
    FuncInfo *info;
    int ret_ops_top;
    uint8 *bcode;
    
    bcode = Method_GetByteCode(method);
    // get method index in constant pool
    index = BCode_get_uint16(bcode + pc + 1);

    // get indexed method information
    // The call_info points to the method structure of the superclass
    // even if the class of referred object defines the method.
    // Therefore we can use the 'method' structure of 'call_info' directly.
    called_method = Method_GetReferredMethod(method, index);

    // The information is only from signature.
    // It does not consider the implicit 'this' reference.
    arg_size = Method_GetArgSize(called_method);
    CFG_UpdateNumOfMaxArgs(cfg, arg_size + 1);

    ret_ops_top = ops_top - (arg_size+1);
    info = Instr_make_func_info(called_method, ops_top, arg_size+1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();
    
    if (flag_call_stat) {
        c_instr = CSeq_create_call_stat_code(cfg, c_instr, called_method, pc);
    }

#ifdef TYPE_ANALYSIS
    if (flag_type_analysis) {
        //Type analysis is done after phase2.
        //Approapriate invocation type is determined during type analysis
        c_instr = CSeq_create_pseudo_invoke_code(cfg, c_instr, pc,
                                                 called_method, 
                                                 InvokeSpecialType,
                                                 info, ret_ops_top);
    } else 
#endif /* TYPE_ANALYSIS */
    {
    bool    need_null_check = true;
    bool    resolved = true;
    int     meth_idx = 0; // meth_idx is not needed when resolved is true
    c_instr = 
	CSeq_make_corresponding_invoke_sequence(cfg, c_instr, pc,
						called_method,
						ret_ops_top,
						NULL,
						NULL, info,
						meth_idx,
						need_null_check,
						resolved);
    }
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(INVOKESTATIC)
{
    //
    // ..., ...args... -> ..., return val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    short arg_size;
    Method *called_method;
    FuncInfo *info;
    int ret_ops_top;
    uint8 *bcode;
    
    bcode = Method_GetByteCode(method);
    // get method index in constant pool
    index = BCode_get_uint16(bcode + pc + 1);

    // get indexed method information
    // The call_info points to the method structure of the superclass
    // even if the class of referred object defines the method.
    // Therefore we can use the 'method' structure of 'call_info' directly.
    called_method = Method_GetReferredMethod(method, index);

    arg_size = Method_GetArgSize(called_method);
    CFG_UpdateNumOfMaxArgs(cfg, arg_size);

    ret_ops_top = ops_top - arg_size;
    info = Instr_make_func_info(called_method, ops_top, arg_size);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();
    
    if (flag_call_stat) {
        c_instr = CSeq_create_call_stat_code(cfg, c_instr, called_method, pc);
    }
#ifdef TYPE_ANALYSIS
    if (flag_type_analysis) {
        //Type analysis is done after phase2.
        //Approapriate invocation type is determined during type analysis
        c_instr = CSeq_create_pseudo_invoke_code(cfg, c_instr, pc,
                                                 called_method, 
                                                 InvokeStaticType,
                                                 info, ret_ops_top);
    } else 
#endif /* TYPE_ANALYSIS */
    {
    bool    need_null_check = false;
    bool    resolved = true;
    int     meth_idx = 0; // meth_idx is not needed when resolved is true

    c_instr = 
	CSeq_make_corresponding_invoke_sequence(cfg, c_instr, pc,
						called_method,
						ret_ops_top,
						NULL,
						NULL, info,
						meth_idx,
						need_null_check,
						resolved);
    }
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

/* interface table structure
        object               dispatch table

	                     interface table
        dtable pointer ----> class pointer
                             dispatch table   */
translate_instr(INVOKEINTERFACE)
{
    //
    // ..., obj ref, ...args... -> ..., return val
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    short arg_size;
    Method *called_method;
    FuncInfo *info;
    int ret_ops_top;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    // get method index in constant pool
    index = BCode_get_uint16(bcode + pc + 1);

    // get indexed method information
    called_method = Method_GetReferredMethod(method, index);

    // The called method should not be "<init>" or "<cinit>".
    // If the method is protected, then it must be either a member of the
    // current class and the class of objref must be either the current
    // class or a subclass of the current class.
    // For efficiency, the checking is not done here.
    // Someday this checking must be implemented.

    // The information is only from signature.
    // It does not consider the implicit 'this' reference.
    arg_size = Method_GetArgSize(called_method);
    CFG_UpdateNumOfMaxArgs(cfg, arg_size + 1);

    ret_ops_top = ops_top - (arg_size+1);
    info = Instr_make_func_info(called_method, ops_top, arg_size+1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();

    if (flag_call_stat) {
        c_instr = CSeq_create_call_stat_code(cfg, c_instr, called_method, pc);
    }

#ifdef TYPE_ANALYSIS
    if (flag_type_analysis) {
        //Type analysis is done after phase2.
        //Approapriate invocation type is determined during type analysis
        c_instr = CSeq_create_pseudo_invoke_code(cfg, c_instr, pc,
                                                 called_method, 
                                                 InvokeInterfaceType,
                                                 info, ret_ops_top);
    } else 
#endif /* TYPE_ANALYSIS */
    {
    bool    need_null_check = true;
    bool    resolved = false;
    int     meth_idx = -called_method->iidx;

    c_instr = 
	CSeq_make_corresponding_invoke_sequence(cfg, c_instr, pc,
						called_method,
						ret_ops_top,
						NULL,
						NULL, info,
						meth_idx,
						need_null_check,
						resolved);
    }

    PROCESS_AND_VERIFY_FOR_NPC(pc + 5);

}

#include "gc.h"

translate_instr(NEW)
{
    //
    // ... -> ..., obj ref
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *class;
    int objsize;
    
    int arg_vars[1];
    int ret_vars[1];

    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    //
    // get information about the class of object to create
    //
    index = BCode_get_uint16(bcode + pc + 1);
    class = getClass(index, Method_GetDefiningClass(method));

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();
    //
    // if (FSIZE(class)+GC_HEAD < GC_MAX_SMALL_OBJECT_SIZE
    //     && class->final == false) {
    //     add   g0, FSIZE(class)+GC_HEAD, it0
    //     call gc_malloc_small (o0 :FSIZE(class)+GC_HEAD, ret: rs{TOP+1})
    //     sethi %hi(class->dtable), rt2
    //     or    r3, rt2, %lo(class->itable)
    //     sethi %hi(class->itable), rt4
    //     or    r5, rt4, %lo(class->itable)
    //     st    rt3, [rs{TOP+1}]
    //     st    rt5, [rs{TOP+1}+ITABLE_INDEX]
    // } else {
    //     sethi %hi(class), rt0
    //     or    rt0, %lo(class), rt1
    //     call  newObject (o0: rt1, ret: rs{TOP+1}
    // }
    //
    objsize = ROUNDUPALIGN(CLASS_FSIZE(class) + GC_HEAD);
    
    if (objsize < GC_MAX_SMALL_OBJECT_SIZE && class->final == false) {
	/* optimized case, direct call to gc_malloc_small */
        arg_vars[0] = IT(0);
        ret_vars[0] = RS(ops_top + 1);

	APPEND_INSTR5(ADD, IT(0),  g0, objsize);
        APPEND_INSTR1(CALL, (int) gc_malloc_small);
        CFGGen_process_for_function_call(cfg, c_instr, gc_malloc_small,
					 1, arg_vars, 1, ret_vars);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

#ifdef TYPE_ANALYSIS
        c_instr->myTypedValue = TV_new(class); 
        TV_SetTypeSource(c_instr->myTypedValue, TVTS_FROM_NEW); 
#endif

        APPEND_INSTR2(SETHI, RT(2), HI(class->dtable));
        APPEND_INSTR5(OR, RT(3), RT(2), LO(class->dtable));
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR8(ST, RT(3), RS(ops_top + 1), 0);
        Instr_SetLastUseOfSrc(c_instr, 1);
    } else {
	/* normal case, call to gc_malloc */
        arg_vars[0] = RT(1);
        ret_vars[0] = RS(ops_top + 1);

	APPEND_INSTR2(SETHI, RT(0), HI(class));
        APPEND_INSTR5(OR, arg_vars[0], RT(0), LO(class));
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR1(CALL, (int) newObject);
        CFGGen_process_for_function_call(cfg, c_instr, newObject,
					 1, arg_vars, 1, ret_vars);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
#ifdef TYPE_ANALYSIS
        c_instr->myTypedValue = TV_new(class); 
        TV_SetTypeSource(c_instr->myTypedValue, TVTS_FROM_NEW); 
#endif

    }

    set_ops_type(ops_top + 1, T_REF);
    ops_top++;

    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(NEWARRAY)
{
    //
    // ..., size -> ..., array ref
    //
    //  sethi %hi(prim_class), rt0
    //  or    rt0, %lo(prim_class), rt1
    //  call  newPrimArray (o0: rt1, o1: is{TOP}, ret: rs{TOP})
    //
    InstrNode *c_instr = p_instr;
    uint8 elem_type;
    Hjava_lang_Class *prim_class;
    int arg_vars[2];
    int ret_vars[1];
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_INT);

    bcode = Method_GetByteCode(method);
    
    elem_type = BCode_get_uint8(bcode + pc + 1);
    prim_class = Class_get_primary_class(elem_type);

    c_instr = CSeq_create_array_size_checking_code(cfg, c_instr, pc,
						   &translated_instrs[pc],
						   ops_top);

    arg_vars[0] = RT(1);
    arg_vars[1] = IS(ops_top);
    ret_vars[0] = RS(ops_top);

    APPEND_INSTR2(SETHI, RT(0), HI(prim_class));
    APPEND_INSTR5(OR, arg_vars[0], RT(0), LO(prim_class));
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR1(CALL, (int) newPrimArray);
    CFGGen_process_for_function_call(cfg, c_instr, newPrimArray,
				     2, arg_vars, 1, ret_vars);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top, T_REF);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 2);
}


translate_instr(ANEWARRAY)
{
    //
    // ..., size -> ..., array ref
    //
    //  sethi %hi(base_class), rt0
    //  or    rt0, %lo(base_class), rp0
    //  call  newRefArray (o0: rt1, o1: is{TOP}, ret: rs{TOP})
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *base_class;
    int arg_vars[2];
    int ret_vars[1];
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    // get information about the class of object to create
    index = BCode_get_uint16(bcode + pc + 1);
    base_class = getClass(index, Method_GetDefiningClass(method));

    assert(get_ops_type(ops_top) == T_INT);

    c_instr = CSeq_create_array_size_checking_code(cfg, c_instr, pc,
						   &translated_instrs[pc],
						   ops_top);

    arg_vars[0] = RT(1);
    arg_vars[1] = IS(ops_top);
    ret_vars[0] = RS(ops_top);

    APPEND_INSTR2(SETHI, RT(0), HI(base_class));
    APPEND_INSTR5(OR, arg_vars[0], RT(0), LO(base_class));
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR1(CALL, (int) newRefArray);
    CFGGen_process_for_function_call(cfg, c_instr, newRefArray,
				     2, arg_vars, 1, ret_vars);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top, T_REF);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}


translate_instr(ARRAYLENGTH)
{
    //
    // ..., array ref -> ..., length
    //
    //   ld [rs{TOP}+ARRAY_SIZE_OFFSET], is{TOP}
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    APPEND_INSTR5(LD, IS(ops_top), RS(ops_top), ARRAY_SIZE_OFFSET);
    Instr_SetLastUseOfSrc(c_instr, 0);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    translated_instrs[pc] = c_instr;

    set_ops_type(ops_top, T_INT);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(ATHROW)
{
    //
    // ..., obj ref -> [empty]
    //
    //  call  throwExternalException (o0: rs{TOP}
    //
    InstrNode *c_instr = p_instr;
    int arg_vars[1];

    assert(get_ops_type(ops_top) == T_REF);

    arg_vars[0] = RS(ops_top);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();

    APPEND_INSTR1(CALL, (int) throwExternalException);
    CFGGen_process_for_function_call(cfg, c_instr, throwExternalException,
				     1, arg_vars, 0, NULL);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    // no successor
    // if this method is inlined method,
    // then, special treatment needs.

    if (IG_GetDepth(CFGGen_current_ig_node) != 0
	&& !Method_HaveReturn(method)) {
        InstrNode *e_instr = IG_GetTail(CFGGen_current_ig_node);
	Method *m;

	m = IG_GetMethod(CFGGen_current_ig_node);
	
        c_instr = CSeq_create_null_returning_code(cfg, c_instr, m);

        Instr_connect_instruction(c_instr, e_instr);
    }
}

// the scheme of treating CHECKCAST and INSTANCEOF is changed.
// Before, class hierachy table is maintained globally, but now each
// class has its own table And CHECKCAST and INSTANCEOF are inlined.
translate_instr(CHECKCAST)
{
    //
    // ..., obj ref -> ..., obj ref
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *class;
    int arg_vars[2];
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    // get the class structure to check
    index = BCode_get_uint16(bcode + pc + 1);
    class = getClass(index, Method_GetDefiningClass(method));

    assert(get_ops_type(ops_top) == T_REF);

    if (flag_opt_checkcast){
        if (class == ObjectClass){
            // do nothing because java.lang.Object is the root class
            // of all the classes
        } else if (class->accflags & ACC_FINAL) {
            //    subcc  rs{TOP}, 0, g0
            //    be     FINISH
            // NORMAL:
            //    ld     [rs{TOP}], rt0
            //    sethi  %hi(class->dtable), rt1
            //    or     rt1, %lo(class->dtable), rt2
            //    subcc  rt0, rt2, g0
            //    tne    0x14
            // FINISH:
            //    NOP
            InstrNode *branch_instr, *end_instr;

            APPEND_INSTR5(SUBCC, g0, RS(ops_top), 0);
            translated_instrs[pc] = c_instr;
            APPEND_INSTR3(BE);
            branch_instr = c_instr;
            CFGGen_process_for_branch(cfg, branch_instr);

            // NORMAL
            APPEND_INSTR5(LD, RT(0), RS(ops_top), 0);
            APPEND_INSTR2(SETHI, RT(1), HI(class->dtable));
            APPEND_INSTR5(OR, RT(2), RT(1), LO(class->dtable));
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR6(SUBCC, g0, RT(0), RT(2));
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_SetLastUseOfSrc(c_instr, 1);
            APPEND_INSTR9(TNE, 0x14);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

            //FINISH
            APPEND_NOP();
            end_instr = c_instr;
            Instr_connect_instruction (branch_instr, end_instr);
            c_instr = end_instr;
        } else {
            //    subcc  rs{TOP}, 0, g0
            //    be     FINISH
            // NORMAL:
            //    ld     [rs{TOP}], rt0   //load dtable
            //    ld     [rt0+DTABLE_ROWOFFSET], rt1
            //    ldub   [rt1+pos>>3], it2
            //    andcc  it2, (0x1 << (7-(pos & 0x7))), g0
            //    te    0x14
            // FINISH:
            //    NOP
            InstrNode *branch_instr, *end_instr;
            int32  pos = Class_GetTypeRep(class)->pos;

            APPEND_INSTR5(SUBCC, g0, RS(ops_top), 0);
            translated_instrs[pc] = c_instr;
            APPEND_INSTR3(BE);
            branch_instr = c_instr;
            CFGGen_process_for_branch(cfg, branch_instr);

            // NORMAL
            APPEND_INSTR5(LD, RT(0), RS(ops_top), 0); //get dtable pointer
            APPEND_INSTR5(LD, RT(1), RT(0), DTABLE_ROWOFFSET); //get row array
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR5(LDUB, IT(2), RT(1), pos >> 3);
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR5(ANDCC, g0, IT(2), (0x1 << (7-(pos & 0x7))));
            Instr_SetLastUseOfSrc(c_instr, 0);
            APPEND_INSTR9(TE, 0x14);
            CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

            //FINISH
            APPEND_NOP();
            end_instr = c_instr;
            Instr_connect_instruction (branch_instr, end_instr);
            c_instr = end_instr;
        }
    } else {
        //
        // sethi   %hi(class), rt0
        // or      rt0, %lo(class), rt1
        // add     rs{TOP}, rt2
        // call    check_cast (o0 : rt1, o1: rt2, ret: void)
        //
	APPEND_INSTR2(SETHI, RT(0), HI(class));
	translated_instrs[pc] = c_instr;
        APPEND_INSTR5(OR, RT(1), RT(0), LO(class));
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR6(ADD, RT(2), RS(ops_top), g0);
        APPEND_INSTR1(CALL, (int) RT_check_cast);

        arg_vars[0] = RT(1);
        arg_vars[1] = RT(2);

	CFGGen_process_for_function_call(cfg, c_instr, RT_check_cast,
					 2, arg_vars, 0, NULL);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    }

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(INSTANCEOF)
{
    //
    // ..., obj ref -> ..., 1|0
    // If obj_ref is null, 0 is pushed.
    //
    InstrNode *c_instr = p_instr;
    InstrNode *branch_instr1, *branch_instr2;
    InstrNode *exit_instr1, *exit_instr2;
    InstrNode *end_instr;

    uint16 index;
    Hjava_lang_Class *class;
    uint8 *bcode;

    int arg_vars[2];
    int ret_vars[1];

    bcode = Method_GetByteCode(method);
    // get the class structure to check
    index = BCode_get_uint16(bcode + pc + 1);
    class = getClass(index, Method_GetDefiningClass(method));

    assert(get_ops_type(ops_top) == T_REF);

    if (flag_opt_instanceof) {
        int npc;
        byte opcode;
        uint8 *bcode;
        bool use_local_lookahead;
        uint8 *binfo;

        npc = pc + 3;
        bcode = Method_GetByteCode(method);
        opcode = BCode_get_uint8(bcode + npc);
        binfo = Method_GetBcodeInfo(method);
        use_local_lookahead = !is_bytecode_join(binfo, npc)
            && (opcode == IFEQ || opcode == IFNE);

        //     subcc  rs{TOP}, 0, g0
        //     be     
        APPEND_INSTR5(SUBCC, g0, RS(ops_top), 0);
        translated_instrs[pc] = c_instr;
        APPEND_INSTR3(BE);
        branch_instr1 = c_instr;
        CFGGen_process_for_branch(cfg, branch_instr1);

        if (use_local_lookahead) {
	    int16 offset = BCode_get_int16(bcode + npc + 1);

            exit_instr1 = NULL; //just to avoid warning
            if (class == ObjectClass){
                APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
                Instr_SetLastUseOfSrc(c_instr, 0);
                exit_instr1 = c_instr;
                branch_instr2 = NULL;
            } else if (class->accflags & ACC_FINAL) { 
                APPEND_INSTR5(LD, RT(0), RS(ops_top), 0);
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR2(SETHI, RT(1), HI(class->dtable));
                APPEND_INSTR5(OR, RT(2), RT(1), LO(class->dtable));
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR6(SUBCC, g0, RT(0), RT(2));
                Instr_SetLastUseOfSrc(c_instr, 0);
                Instr_SetLastUseOfSrc(c_instr, 1);
                APPEND_INSTR3(BNE);
                branch_instr2 = c_instr;
            } else {
                int32  pos = Class_GetTypeRep(class)->pos;

                APPEND_INSTR5(LD, RT(0), RS(ops_top), 0); //get dtable pointer
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR5(LD, RT(1), RT(0), DTABLE_ROWOFFSET); //get row array
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR5(LDUB, IT(2), RT(1), pos >> 3);
                Instr_SetLastUseOfSrc(c_instr, 0);

                APPEND_INSTR5(ANDCC, g0, IT(2), (0x1 << (7-(pos & 0x7))));
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR3(BE);
                branch_instr2 = c_instr;
            }

            c_instr = branch_instr1;
            APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            exit_instr2 = c_instr;

            if (branch_instr2) {
                CFGGen_process_for_branch(cfg, branch_instr2);
                c_instr = branch_instr2;
                APPEND_NOP();
                exit_instr1 = c_instr;

                Instr_connect_instruction (branch_instr2, exit_instr2);
            }
            ops_top--;

            have_multi_successors = true;

            if (opcode == IFEQ) {
              c_instr = exit_instr2;
              PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

              c_instr = exit_instr1;
              PROCESS_AND_VERIFY_FOR_NPC(npc + 3);
            } else { /* opcode == IFNE */
              c_instr = exit_instr1;
              PROCESS_AND_VERIFY_FOR_NPC(npc + offset);

              c_instr = exit_instr2;
              PROCESS_AND_VERIFY_FOR_NPC(npc + 3);
            }
            return;

        } else { /* do not use local lookahead */
            if (class == ObjectClass){
                APPEND_INSTR6(ADD, g0, RS(ops_top), g0);
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR5(ADD, IS(ops_top), g0, 1);
//             } else if (class->accflags & ACC_FINAL) { 
//                 APPEND_INSTR5(LD, RT(0), RS(ops_top), 0);
//                 Instr_SetLastUseOfSrc(c_instr, 0);
//                 APPEND_INSTR2(SETHI, RT(1), HI(class->dtable));
//                 APPEND_INSTR5(OR, RT(2), RT(1), LO(class->dtable));
//                 Instr_SetLastUseOfSrc(c_instr, 0);
//                 APPEND_INSTR6(SUBCC, g0, RT(0), RT(2));
//                 Instr_SetLastUseOfSrc(c_instr, 0);
//                 Instr_SetLastUseOfSrc(c_instr, 1);
//                 APPEND_INSTR3(BNE);
//                 branch_instr2 = c_instr;
            } else {
                int32  pos = Class_GetTypeRep(class)->pos;

                APPEND_INSTR5(LD, RT(0), RS(ops_top), 0); //get dtable pointer
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR5(LD, RT(1), RT(0), DTABLE_ROWOFFSET); //get row array
                Instr_SetLastUseOfSrc(c_instr, 0);
                APPEND_INSTR5(LDUB, IT(2), RT(1), pos >> 3);
                Instr_SetLastUseOfSrc(c_instr, 0);

                APPEND_INSTR5(AND, IT(3), IT(2), (0x1 << (7-(pos & 0x7))));
                Instr_SetLastUseOfSrc(c_instr, 0);
                if ((7-(pos & 0x7)) != 0) {
                    APPEND_INSTR5(SRL, IS(ops_top), IT(3), (7-(pos & 0x7)));
                    Instr_SetLastUseOfSrc(c_instr, 0);
                } else {
                    APPEND_INSTR6(ADD, IS(ops_top), IT(3), g0);
                    Instr_SetLastUseOfSrc(c_instr, 0);
                }
            }
         
            APPEND_NOP();
            end_instr = c_instr;

            c_instr = branch_instr1;
            APPEND_INSTR6(ADD, IS(ops_top), RS(ops_top), g0);
            Instr_SetLastUseOfSrc(c_instr, 0);
            Instr_connect_instruction(c_instr, end_instr);

            c_instr = end_instr;
        }
    } else {
        //
        //    sethi   %hi(class), rt0
        //    or      rt0, %lo(class), rt1
        //    call    is_instanceof (o0: rt1, o1: rs{TOP}, ret: is{TOP})
        //
	APPEND_INSTR2(SETHI, RT(0), HI(class));
        translated_instrs[pc] = c_instr;
        APPEND_INSTR5(OR, RT(1), RT(0), LO(class));
        Instr_SetLastUseOfSrc(c_instr, 0);
        APPEND_INSTR1(CALL, (int) RT_is_instanceof);

        arg_vars[0] = RT(1);
        arg_vars[1] = RS(ops_top);
        ret_vars[0] = IS(ops_top);

        CFGGen_process_for_function_call(cfg, c_instr, RT_is_instanceof,
					 2, arg_vars, 1, ret_vars);
        CFG_MarkExceptionGeneratableInstr(cfg, c_instr);
    }

    set_ops_type(ops_top, T_INT);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(MONITORENTER)
{
    //
    // ..., obj ref -> ...
    //
    // monitorenter code sequence is in the file 'code_sequence.c'
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);

    c_instr = CSeq_create_monitorenter_code(cfg, c_instr, pc,
					    &translated_instrs[pc],
					    RS(ops_top));

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(MONITOREXIT)
{
    //
    // ..., obj ref -> ...
    //
    // monitorexit code sequence is in the file 'code_sequence.c'
    //
    InstrNode *c_instr = p_instr;

    assert(get_ops_type(ops_top) == T_REF);
    
    c_instr = CSeq_create_monitorexit_code(cfg, c_instr, pc,
					   &translated_instrs[pc],
					   RS(ops_top));

    ops_top--;

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

translate_instr(WIDE)
{
    //
    // ... -> ...
    //
    InstrNode *c_instr = p_instr;

    wide = true;

    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    PROCESS_AND_VERIFY_FOR_NPC(pc + 1);
}

static
bool
check_valid_ops(int top, int dim)
{
    int i;

    for(i = 0; i < dim; i++) {
	assert(get_ops_type(top - i) == T_INT);
    }
    return true;
}

translate_instr(MULTIANEWARRAY)
{
    //
    // ..., size1, size2, ..., sizen -> ..., array ref
    //
    InstrNode *c_instr = p_instr;
    uint16 index;
    Hjava_lang_Class *class;
    uint8 dim;
    int i;

    int *arg_vars;
    int ret_vars[1];

    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    // get information about the class of object to create
    index = BCode_get_uint16(bcode + pc + 1);
    class = getClass(index, Method_GetDefiningClass(method));

    // get the dimension of array
    dim = BCode_get_uint8(bcode + pc + 3);

    // check if the stack state is valid
    assert(check_valid_ops(ops_top, dim));
    
    arg_vars = (int *) alloca(sizeof(int) * (dim + 2));
    //
    // sethi %hi(class), rt0
    // or    rt0, %lo(class), rt1
    // add   g0, dim, it2
    // call  soft_multianewarray
    //
    // (o0: rt1, o1: it2, o3: is{TOP-dim+1}, ..., o5: is{TOP-dim+4},
    // ..., ret: rs{TOP-dim+1})
    //
    arg_vars[0] = RT(1);
    arg_vars[1] = IT(2);

    for (i = 1; i <= dim; i++) {
        arg_vars[i + 1] = IS(ops_top - dim + i);
    }

    ret_vars[0] = RS(ops_top - dim + 1);

    APPEND_INSTR2(SETHI, RT(0), HI(class));
    translated_instrs[pc] = c_instr;
    APPEND_INSTR5(OR, arg_vars[0], RT(0), LO(class));
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR5(ADD, arg_vars[1], g0, dim);
    CFG_UpdateNumOfMaxArgs(cfg, dim + 2);
    APPEND_INSTR1(CALL, (int) soft_multianewarray);
    CFGGen_process_for_function_call(cfg, c_instr, soft_multianewarray,
				     dim + 2, arg_vars, 1, ret_vars);
    CFG_MarkExceptionGeneratableInstr(cfg, c_instr);

    set_ops_type(ops_top - (dim - 1), T_REF);

    ops_top -= (dim - 1);

    INSERT_DEBUG_CODE();
    PROCESS_AND_VERIFY_FOR_NPC(pc + 4);
}

translate_instr(IFNULL)
{
    //
    // ..., val -> ...
    //
    //    subcc   rs{TOP}, g0, g0
    //    be      SUCC2
    // SUCC1:
    //============================================================
    //              VLIW ISA
    //============================================================
    //    se      rs{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int32 offset;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_REF);

    bcode = Method_GetByteCode(method);
    offset = BCode_get_int16(bcode + pc + 1);

    APPEND_NOP();
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();


    APPEND_INSTR6(SUBCC, g0, RS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BE);
    CFGGen_process_for_branch(cfg, c_instr);
    

    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(IFNONNULL)
{
    //
    // ..., val -> ...
    //
    //    subcc   rs{TOP}, g0, g0
    //    bne     SUCC2
    // SUCC1:
    //==================================================================
    //              VLIW ISA
    //==================================================================
    //    sne     rs{TOP}, g0, cc
    //    jset    cc, SUCC2
    // SUCC1:
    //
    InstrNode *c_instr = p_instr;
    int npc;
    int16 offset;
    uint8 *bcode;

    assert(get_ops_type(ops_top) == T_REF);

    bcode = Method_GetByteCode(method);
    offset = BCode_get_int16(bcode + pc + 1);
    APPEND_NOP();
    translated_instrs[pc] = c_instr;

    INSERT_DEBUG_CODE();

    APPEND_INSTR6(SUBCC, g0, RS(ops_top), g0);
    Instr_SetLastUseOfSrc(c_instr, 0);
    APPEND_INSTR3(BNE);
    CFGGen_process_for_branch(cfg, c_instr);


    ops_top--;

    have_multi_successors = true;

    npc = pc + offset;
    PROCESS_AND_VERIFY_FOR_NPC(npc);

    npc = pc + 3;
    PROCESS_AND_VERIFY_FOR_NPC(npc);
}

translate_instr(JSR)
{
    //
    // After invocation:
    // ... -> ..., ret_addr
    // After return from subroutine:
    // ..., ret_addr -> ...
    //
    // finally block is handled by inlining
    //
    InstrNode *c_instr = p_instr;
    uint8 *bcode;
    int addr;

    bcode = Method_GetByteCode(method);
    addr = pc + BCode_get_int16(bcode + pc + 1);

    APPEND_INSTR1(GOSUB, 0);
    translated_instrs[pc] = c_instr;
    CFG_RegisterFinallyBlock(cfg, addr, c_instr, ops_top);
    INSERT_DEBUG_CODE();

    // After the finally block returns, the operand stack is the same
    // as before.
    PROCESS_AND_VERIFY_FOR_NPC(pc + 3);
}

translate_instr(RET)
{
    //
    // ... -> ...
    //
    // jmpl  rl{index}, 8, g0
    //
    InstrNode *c_instr = p_instr;
    uint8 index;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    index = BCode_get_uint8(bcode + pc + 1);

    APPEND_INSTR6(ADD, g0, RL(index), g0);
    translated_instrs[pc] = c_instr;
    INSERT_DEBUG_CODE();

    //
    // set 'last_ret_translate_instr' to use in the stage 3
    //
    last_ret_translate_instr = c_instr;

    // no successor
}

translate_instr(JSR_W)
{
    //
    // After invocation:
    // ... -> ..., ret_addr
    // After return from subroutine:
    // ..., ret_addr -> ...
    //
    // finally block is handled by inlining
    //
    InstrNode *c_instr = p_instr;
    int addr;
    uint8 *bcode;

    bcode = Method_GetByteCode(method);
    addr = pc + BCode_get_int32(bcode + pc + 1);

    APPEND_INSTR1(GOSUB, 0);
    translated_instrs[pc] = c_instr;
    CFG_RegisterFinallyBlock(cfg, addr, c_instr, ops_top);

    INSERT_DEBUG_CODE();

    // After the finally block returns, the operand stack is the same
    // as before.
    PROCESS_AND_VERIFY_FOR_NPC(pc + 5);
}

